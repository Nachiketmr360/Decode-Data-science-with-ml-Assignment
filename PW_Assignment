Q1.1: Write the Answer to these questions.

• What is the difference between static and dynamic variables in python?

ans) Static Variables Definition: Static variables, also known as class variables, are variables that are shared among all instances of a class.

1.Scope: They are defined within a class but outside any instance methods.

Dynamic Variables Definition: Dynamic variables, often referred to as instance variables, are unique to each instance of a class.

1.Scope: They are defined within methods, usually the' init' method, and are prefixed with 'self' to indicate they belong to the instance.

• Explain the purpose of "pop","popitem", and "clear()" in a dictionary with suitable examples.

pop Method Purpose: The pop method removes the specified key and returns the corresponding value. If the key is not found, it raises a KeyError, unless a default value is provided. ex:

print(my_dict.pop('b'))  # Output: 2
print(my_dict)  # Output: {'a': 1, 'c': 3}

print(my_dict.pop('d', 'Not Found'))  # Output: Not Found
print(my_dict)  # Output: {'a': 1, 'c': 3}
popitem Method Purpose: The popitem method removes and returns the last key-value pair as a tuple. If the dictionary is empty, it raises a KeyError.

print(my_dict.popitem())  # Output: ('c', 3)
print(my_dict)  # Output: {'a': 1, 'b': 2}
clear Method Purpose: The clear method removes all items from the dictionary, leaving it empty.

https://colab.research.google.com/drive/1hjgOanZBKDzd2bZ6wRMluW1u3AfxvCNn#scrollTo=-lPY-epTr3U9&line=1&uniqifier=1
(If you get any issue with reading it visit google colab using above link)
my_dict.clear()
print(my_dict)  # Output: {}
• What do you mean by FrozenSet? Explain it with suitable examples.

A frozenset in Python is an immutable set, meaning its elements cannot be modified after creation. It can be used as dictionary keys or set elements because it is hashable.

fs = frozenset([1, 2, 3])
print(fs)  # Output: frozenset({1, 2, 3})

my_dict = {fs: "Group 1"}
print(my_dict[fs])  # Output: Group 1
• Differentiate between mutable and immutable data types in python and give examples of mutable and immutable data types.

Mutable Data Types: List: lst = [1, 2, 3] Dictionary: dct = {'a': 1, 'b': 2} Set: st = {1, 2, 3} Immutable Data Types: string: s = "hello" Tuple: tpl = (1, 2, 3) Frozenset: fs = frozenset([1, 2, 3])

lst = [1, 2, 3]
lst.append(4)
print(lst)  # Output: [1, 2, 3, 4]

# Immutable
s = "hello"
# s[0] = 'H'  # This will raise an error
• What is init ? explain with an example.

init is a special method in Python classes, called a constructor, which is automatically invoked when a new instance of the class is created. It initializes the instance's attributes

    def __init__(self, name, age):
        self.name = name
        self.age = age

p1 = Person("Alice", 30)
print(p1.name)  # Output: Alice
print(p1.age)   # Output: 30
• What is docstring in Python?Explain with an example.

A docstring in Python is a string literal that appears right after the definition of a function, method, class, or module. It is used to document the purpose and behavior of the component.

    """This function greets the person whose name is passed as an argument."""
    return f"Hello, {name}!"

print(greet.__doc__)  # Output: This function greets the person whose name is passed as an argument.
• What are unit tests in Python?

Unit tests in Python are a way to test small parts of your code to make sure they work correctly. They help you catch bugs early and ensure that changes to your code don't break existing functionality. Here's a simple example using the unittest module:


def add(a, b):
    return a + b

class TestAddFunction(unittest.TestCase):
    def test_add(self):
        self.assertEqual(add(2, 3), 5)  # Check if add(2, 3) returns 5
        self.assertEqual(add(-1, 1), 0)  # Check if add(-1, 1) returns 0

if __name__ == '__main__':
    unittest.main()
• What is break, continue and pass in python? break Purpose: Terminates the nearest enclosing loop (for loop, while loop, or nested loops).

for i in range(5):
    if i == 3:
        break
    print(i)
# Output: 0, 1, 2
continue Purpose: Skips the current iteration of a loop and proceeds to the next iteration.

    if i == 2:
        continue
    print(i)
# Output: 0, 1, 3, 4
pass Purpose: Does nothing and acts as a placeholder where syntactically required.

    if i == 2:
        pass  # Placeholder, does nothing
    print(i)
# Output: 0, 1, 2, 3, 4
• What is the use of self in Python?

self is used inside class methods to refer to the instance (object) itself. It allows methods to access and modify instance attributes.

class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age

    def greet(self):
        return f"Hello, my name is {self.name} and I am {self.age} years old."

# Creating an instance of Person
p = Person("Alice", 30)
print(p.greet())  # Output: Hello, my name is Alice and I am 30 years old.
• What are globa , protected and private attributes in Python?

Global Attributes: Variables defined at the module level, accessible throughout the module.


def some_function():
    print(global_var)

some_function()  # Output: 10
Protected Attributes: Conventionally marked with a single leading underscore (_). It suggests that the attribute should be used within its class or module.

class MyClass:
    def __init__(self):
        self._protected_var = 20

    def get_protected_var(self):
        return self._protected_var

obj = MyClass()
print(obj.get_protected_var())  # Output: 20
Private Attributes: Indicated by a double leading underscore (__). It triggers name mangling to make the attribute less accessible from outside the class.

    def __init__(self):
        self.__private_var = 30

    def get_private_var(self):
        return self.__private_var

obj = MyClass()
# Directly accessing __private_var will raise an AttributeError
print(obj.get_private_var())  # Output: 30
• What are modules and packages in python?

Modules: Modules in Python are files containing Python code that define functions, classes, and variables. They help organize code into reusable units, making it easier to manage and maintain.

# math_operations.py
def add(a, b):
    return a + b

# main.py
import math_operations

print(math_operations.add(5, 3))  # Output: 8
Packages: Packages are directories containing multiple Python modules along with a special init.py file. They provide a way to structure and namespace Python's module namespace, allowing for hierarchical organization of code.

# my_package/module1.py
def func1():
    print("Function 1")

# my_package/module2.py
def func2():
    print("Function 2")

# main.py
from my_package import module1, module2

module1.func1()  # Output: Function 1
module2.func2()  # Output: Function 2
• What are lists and tuples? What is the key difference between the two?

Lists: Mutable sequences of elements, defined with square brackets [ ].

Tuples: Immutable sequences of elements, defined with parentheses ( ).

my_list = [1, 2, 3]

# Tuple example
my_tuple = (1, 2, 3)
• What is an Interpreted language & dynamically typed language?Write 5 differences between them.

Interpreted vs Dynamically Typed Language:

Interpreted Language: Code is executed line by line without compiling (e.g., Python). Dynamically Typed Language: Variable types are determined at runtime, allowing flexibility but potentially leading to runtime errors.

x = 5  # Integer
x = "hello"  # String
• What are Dict and List comprehensions?

Dict and List Comprehensions:

List Comprehension: Concise way to create lists based on existing lists. Dict Comprehension: Similar to list comprehension but creates dictionaries

squares = [x**2 for x in range(5)]

# Dict comprehension
square_dict = {x: x**2 for x in range(5)}
• What are decorators in Python? Explain it with an example.Write down its use cases.

Decorators:

Functions that modify the behavior of other functions or methods without changing their code. Used for adding functionalities like logging, timing, or access control.

    def wrapper():
        print("Something is happening before the function is called.")
        func()
        print("Something is happening after the function is called.")
    return wrapper

@my_decorator
def say_hello():
    print("Hello!")

say_hello()
• How is memory managed in Python?

Memory Management in Python:

Handled automatically by Python's memory manager using techniques like reference counting and garbage collection. Ensures efficient allocation and deallocation of memory.

• What is lambda in python? Why is it used?

Lambda Functions:

Small anonymous functions defined with lambda keyword. Used for short functions where def syntax is overly verbose

add = lambda x, y: x + y
print(add(3, 5))  # Output: 8
• Explain split() and join() functions in Python?

split(): Splits a string into a list of substrings based on a delimiter.

join(): Concatenates elements of an iterable into a string, with a specified separator.

sentence = "Hello, world!"
words = sentence.split(", ")  # Output: ['Hello', 'world!']
new_sentence = "-".join(words)  # Output: 'Hello-world!'
• What are iterators , iterable & generators in Python?

Iterable: Any object capable of returning its members one at a time (e.g., lists, tuples).

Iterator: Object used to iterate through an iterable using iter() and next() methods.

Generators: Functions that generate a sequence of values lazily, using yield instead of return.

def square_numbers(n):
    for i in range(n):
        yield i ** 2

my_gen = square_numbers(5)
print(list(my_gen))  # Output: [0, 1, 4, 9, 16]
• What is the difference between xrange and range in python?

range: Returns a list of numbers and stores them in memory.

xrange: Generates numbers on-the-fly, using less memory, but available only in Python 2 (in Python 3, range behaves like xrange).

for i in xrange(5):
    print(i)
• Pillars of Oops.

Pillars of OOPs:

Encapsulation: Bundling of data and methods that operate on the data.

Inheritance: Ability of a class to inherit properties and methods from another class.

Polymorphism: Ability to use a single interface for different data types or classes.

Abstraction: Hiding complex implementation details and showing only relevant information.

• How will you check if a class is a child Of another class?

Use issubclass() function to check if a class is a subclass of another class.

    pass

class Child(Parent):
    pass

print(issubclass(Child, Parent))  # Output: True
• How does inheritance work in python? Explain all types of inheritance with an example.

Inheritance in Python:

Mechanism where a new class derives attributes and methods from an existing class.

Types include single, multiple, multilevel, and hierarchical inheritance.

class Parent:
    def show(self):
        print("Parent method")

class Child(Parent):
    pass

obj = Child()
obj.show()  # Output: Parent method
• What is encapsulation? Explain it with an example.

Encapsulation is the bundling of data and methods that operate on the data into a single unit (class). Ex:

    def __init__(self, brand):
        self.brand = brand
        self.__mileage = 0  # Private attribute

    def drive(self):
        self.__mileage += 10

my_car = Car("Toyota")
my_car.drive()
# Accessing private attribute directly will raise an AttributeError
• What is polymorphism? Explain it with an example.

Polymorphism allows methods to be written in a way that they can take multiple forms or implementations. Ex:

    def sound(self):
        print("Bark")

class Cat:
    def sound(self):
        print("Meow")

def make_sound(animal):
    animal.sound()

make_sound(Dog())  # Output: Bark
make_sound(Cat())  # Output: Meow
Q1.2. Which of the following identifier names are invalid and why? Serial_no. 1st_Room Hundred$ Total_Marks total-Marks Total Marks True _ percentag

1.serial_no. -- it's valid identifier

2.1st_room -- it's invalid identifier due to having number at the begining.

3.Hundred$ - it's valid identifier

4.Total_Marks -- it's valid identifier

5.total-marks -- it's invalid identifier due to hyphens (-) are not allowed

6.Total Marks -- it's invalid identifier due to space are not allowed

7.True -- it's invalid identifier due to Keywords are not allowed

8._percentag - it's valid identifier

Question 1.3. name = ('Mohan•, "dash", "karam•, do the following operations in this list; a) add an element "freedom_fighter" in this list at the 0th index.

name_list = list(name)
name_list.insert(0, "freedom_fighter")
name = tuple(name_list)

print(name)  # Output: ('freedom_fighter', 'Mohan', 'dash', 'karam')
b) find the output of the following rand explain how?

name = ["freedeomFighter","Bapuji","MOhan","dash", "karam","chandra","gandhi"] length1 = len((name[-len(name)+1:-1:2])) length2 = len((name[-len(name)+1:-1])) print(length1+length2)

name = ["freedeomFighter", "Bapuji", "MOhan", "dash", "karam", "chandra", "gandhi"]
length1 = len(name[1:-1:2])
length2 = len(name[1:-1])
print(length1 + length2)  # Output: 8
The code calculates lengths of two slices of the list and sums them.

length1 is 3 and length2 is 5. The sum is 8.

c) Add Two more elements in the name ["Netaji","Bose"] at the end of the list

name = ["freedeomFighter", "Bapuji", "MOhan", "dash", "karam", "chandra", "gandhi"]
name.extend(["Netaji", "Bose"])
print(name)
d) What will be the value of temp: name = ["Bapuji","dash","karam","chandra","gandhi","mohan"] temp = name[-1] name[-1] =name[0] name[0] = temp print(name)

ans) (outpur) name = ['mohan', 'dash', 'karam', 'chandra', 'gandhi', 'Bapuji']

Question 1.4.Find the output of the following.

animal = ["Human","cat","mat","cat","rat","Human"] print(animal.count('Human')) print(animal.index('rat')) print(len(animal))

print(animal.count('Human')) #output 2
print(animal.index('rat')) #output 4
print(len(animal)) #output 6
Q1.5) tuple1 = (10,20,"apple",3.4,"a",["master","ji"],("sita","geeta",22),[{"roll_no":1},{"name":"Navneet"}])

a)print(len(tuple1)) b)print(tuple1[-1][-1]["name"]) c)fetch the value of rool_no from this tuple. d)print(tuple1[-3][1]) e)fetch the element "22" from this tuple.


# a) Print length of the tuple
print(len(tuple1))  # Output: 8

# b) Print the value associated with the key "name"
print(tuple1[-1][-1]["name"])  # Output: Navneet

# c) Fetch the value of "roll_no"
print(tuple1[-1][0]["roll_no"])  # Output: 1

# d) Print the second element of the seventh item in the tuple
print(tuple1[-3][1])  # Output: geeta

# e) Fetch the element "22" from the tuple
print(tuple1[-3][-1])  # Output: 22
1.6. Write a program to display the appropriate message as per the color Of signal(RED-Stop/YeIIow-Stay/Green-Go) at the road crossing.

signal = input("Enter the signal color (RED/Yellow/Green): ").strip().lower()

if signal == 'red':
    print("Stop")
elif signal == 'yellow':
    print("Stay")
elif signal == 'green':
    print("Go")
else:
    print("Invalid color")
1.7. Write a program to create a simple calculator performing only four basic perations(+,-,/,* ).

def calculator(a, b, operation):
    if operation == '+':
        return a + b
    elif operation == '-':
        return a - b
    elif operation == '*':
        return a * b
    elif operation == '/':
        return a / b
    else:
        return "Invalid operation"

a = float(input("Enter first number: "))
b = float(input("Enter second number: "))
operation = input("Enter operation (+, -, *, /): ")

result = calculator(a, b, operation)
print("The result is:", result)
1.8. Write a program to find the larger of the three pre- specified numbers using temary operators.

a, b, c = 5, 10, 3
largest = a if a > b and a > c else b if b > c else c
print("The largest number is:", largest)
1.9. Write a program to find the factors Of a whole number using a while loop.

number = int(input("Enter a whole number: "))
i = 1

while i <= number:
    if number % i == 0:
        print(i)
    i += 1
1.10. Write a program to find the sum of all the positive numbers entered by the user. As soon as the user enters a negative number, stop taking in any further input from the user and display the sum .

total = 0

while True:
    num = int(input("Enter a number: "))
    if num < 0:
        break
    total += num

print("The sum is:", total)
1.11. Write a program to find prime numbers between 2 to 100 using nested for loops.

for num in range(2, 101):
    is_prime = True
    for i in range(2, int(num ** 0.5) + 1):
        if num % i == 0:
            is_prime = False
            break
    if is_prime:
        print(num)
1.12. Write the programs for the following: Screenshot 2024-07-13 141144.png

(if image not visible)

Criteria Grade
percentage > 85 A

percentage < 85 && percentage >= 75 B

percentage < 75 && percentage >= 50 c

percentage > 30 && percentage 50 D

percentage `<30 Reappear

Q)Accept and Display Marks of Five Subjects

a)Allows the user to input marks for five subjects and stores them in a list marks, then prints the list.

# Accept marks of five subjects from the user
marks = []
for i in range(5):
    subject_marks = float(input(f"Enter marks for subject {i+1}: "))
    marks.append(subject_marks)

# Display the marks of all subjects
print("Marks obtained in five subjects:", marks)
Q)Calculate Sum and Percentage of Marks

a) Calculates the total marks and percentage based on the marks entered. It divides the total marks by 5 to get the average and then calculates the percentage, finally printing both.

# Calculate sum of marks
total_marks = sum(marks)

# Calculate percentage
percentage = (total_marks / (5 * 100)) * 100

# Display the sum and percentage
print(f"Total marks obtained: {total_marks}")
print(f"Percentage: {percentage}%")
Q)Find Grade Based on Percentage Using if-elif Statements

a)Determines the grade based on the calculated percentage using if-elif statements. It checks the percentage against predefined ranges and assigns a grade accordingly, then displays the grade.

# Determine grade based on percentage using if-elif statements
if percentage > 85:
    grade = "A"
elif percentage >= 75:
    grade = "B"
elif percentage >= 50:
    grade = "C"
elif percentage >= 30:
    grade = "D"
else:
    grade = "Reappear"

# Display the grade
print(f"Grade: {grade}")
1.13. Write a program for VIBGYOR Spectrum based on their Wavelength using. Wavelength Range:

Color Wavelength Range (nanometers)
Violet 400 - 440

Indigo 440 - 460

Blue 460 - 500

Green 500 - 570

Yellow 570 - 590

Orange 590 - 620

Red 620 - 720

wavelength = float(input("Enter the wavelength in nanometers: "))

# Determine and print the corresponding color
if 400 <= wavelength < 440:
    print("The color is Violet")
elif 440 <= wavelength < 460:
    print("The color is Indigo")
elif 460 <= wavelength < 500:
    print("The color is Blue")
elif 500 <= wavelength < 570:
    print("The color is Green")
elif 570 <= wavelength < 590:
    print("The color is Yellow")
elif 590 <= wavelength < 620:
    print("The color is Orange")
elif 620 <= wavelength <= 720:
    print("The color is Red")
else:
    print("Wavelength is outside the visible spectrum")
1.14.Consider the gravitational interactions between the Earth, Moon, and Sun in Our solar system.

Given: mass _earth = 5.972e24 # Mass of Earth in kilograms

mass _moon = 7.34767309e22 # Mass of Moon in kilograms

mass_sun=1.989e30 # Mass of Sun in kilograms

distance_earth _sun 1.496e11 # Average distance between Earth and Sun in meters

distance_ moon_earth 3.844e8 # Average distance between Moon and Earth in meters Tasks:

• Calculate the gravitational force between the Earth and the Sun.

# Constants
G = 6.67430e-11  # Gravitational constant in m^3 kg^-1 s^-2

# Given masses and distance
mass_earth = 5.972e24  # Mass of Earth in kilograms
mass_sun = 1.989e30  # Mass of Sun in kilograms
distance_earth_sun = 1.496e11  # Average distance between Earth and Sun in meters

# Calculate gravitational force between Earth and Sun
force_earth_sun = G * (mass_earth * mass_sun) / (distance_earth_sun ** 2)

print(f"The gravitational force between Earth and Sun is {force_earth_sun:.2e} Newtons")
Calculate the Gravitational Force between Moon and Earth

# Given mass and distance
mass_moon = 7.34767309e22  # Mass of Moon in kilograms
distance_moon_earth = 3.844e8  # Average distance between Moon and Earth in meters

# Calculate gravitational force between Moon and Earth
force_moon_earth = G * (mass_moon * mass_earth) / (distance_moon_earth ** 2)

print(f"The gravitational force between Moon and Earth is {force_moon_earth:.2e} Newtons")
Compare the Gravitational Forces

# Compare the gravitational forces
if force_earth_sun > force_moon_earth:
    stronger_force = "Earth and Sun"
else:
    stronger_force = "Moon and Earth"

print(f"The stronger gravitational force is between {stronger_force}")
• Explain which celestial body (Earth or Moon) is more attracted to the other based on the comparison.

1.The gravitational force between the Earth and the Sun is much stronger than the gravitational force between the Moon and the Earth.

2.This means that Earth is more attracted to the Sun than to the Moon.

3.Despite the Moon being much closer to Earth than the Sun, the Sun's significantly larger mass results in a much stronger gravitational pull on Earth compared to the Moon.

Q2. Design and implement a python program for managing student information using object—oriented principles. Create a class called -student- with encapsulated attributes for name, age, and roll number. Implement getter and setter methods for these attributes. Additionally, provide methods to display student information and update student details.

Tasks:

• Define the •Student' class with encapsulated attributes. class Student:

    def __init__(self, name, age, roll_number):
        self.__name = name
        self.__age = age
        self.__roll_number = roll_number

    # Getter methods
    def get_name(self):
        return self.__name

    def get_age(self):
        return self.__age

    def get_roll_number(self):
        return self.__roll_number

    # Setter methods
    def set_name(self, name):
        self.__name = name

    def set_age(self, age):
        self.__age = age

    def set_roll_number(self, roll_number):
        self.__roll_number = roll_number
Implement Getter and Setter Methods for the Attributes

    # Method to display student information
    def display_info(self):
        print(f"Name: {self.__name}, Age: {self.__age}, Roll Number: {self.__roll_number}")

    # Method to update student details
    def update_details(self, name=None, age=None, roll_number=None):
        if name:
            self.__name = name
        if age:
            self.__age = age
        if roll_number:
            self.__roll_number = roll_number
Create Instances Of the Student Class and Test the Implemented Functionality

# Create instances of Student class
student1 = Student("John Doe", 18, "S123")
student2 = Student("Jane Smith", 20, "S456")

# Display initial information
student1.display_info()
student2.display_info()

# Update student1's details
student1.set_age(19)
student1.update_details(name="Johnathan Doe")

# Display updated information
student1.display_info()
Q3.Develop a python program for managing library resources efficiently. Design a class named -LibraryB00kwith attributes like book name, author, and availability Status. Implement methods for borrowing and returning books while ensuring proper encapsulation Of attributes.

Tasks:

• Create the -LibraryBook' class with encapsulated attributes.

class LibraryBook:
    def __init__(self, book_name, author, availability=True):
        self.__book_name = book_name
        self.__author = author
        self.__availability = availability
Implement Methods for Borrowing and Returning Books

    def borrow_book(self):
        if self.__availability:
            self.__availability = False
            print(f"Borrowed: {self.__book_name}")
        else:
            print(f"Sorry, {self.__book_name} is not available.")

    def return_book(self):
        if not self.__availability:
            self.__availability = True
            print(f"Returned: {self.__book_name}")
        else:
            print(f"{self.__book_name} was not borrowed.")
Ensure Proper Encapsulation to Protect Book Details

    def get_details(self):
        return f"Book: {self__book_name}, Author: {self.__author}, Available: {self.__availability}"
Test the Borrowing and Returning Functionality with Sample Data

book1 = LibraryBook("Python Programming", "John Doe")
book2 = LibraryBook("Data Structures", "Jane Smith", False)

# Test borrowing and returning
print(book1.get_details())
book1.borrow_book()
print(book1.get_details())
book1.return_book()
print(book1.get_details())

print(book2.get_details())
book2.borrow_book()
book2.return_book()
Q4.Create a simple banking System using Object-oriented concepts in python. Design classes representing different types Of bank accounts such as savings and checking. Implement methods for deposit, withdraw, and balance inquiry. Utilize inheritance to manage different account types efficiently.

Tasks:

• 1. Define base class(es) for bank accounts with common attributes and methods.

class BankAccount:
    def __init__(self, account_holder, balance=0):
        self.account_holder = account_holder
        self.balance = balance

    def deposit(self, amount):
        self.balance += amount
        print(f"Deposited {amount}. New balance: {self.balance}")

    def withdraw(self, amount):
        if amount > self.balance:
            print("Insufficient funds.")
        else:
            self.balance -= amount
            print(f"Withdrew {amount}. New balance: {self.balance}")

    def get_balance(self):
        return self.balance
Implement Subclasses for Specific Account Types
class SavingsAccount(BankAccount):
 def __init__(self, account_holder, balance=0):
     super().__init__(account_holder, balance)
class CheckingAccount(BankAccount):
 def __init__(self, account_holder, balance=0):
     super().__init__(account_holder, balance)
Provide Methods for Deposit, Withdraw, and Balance Inquiry in Each Subclass
a3)Methods are inherited from the base class, so no need to redefine them.

Test the Banking System by Creating Instances of Different Account Types and Performing Transactions
savings = SavingsAccount("Alice", 1000)
checking = CheckingAccount("Bob", 500)

# Test deposit, withdraw, and balance inquiry
savings.deposit(500)
savings.withdraw(200)
print(f"Savings Account Balance: {savings.get_balance()}")

checking.deposit(300)
checking.withdraw(800)
print(f"Checking Account Balance: {checking.get_balance()}")
Q5)Write a python program that models different animals and their sounds. Design a base class called •Animal* with a method Create subclasses like 'Dog' and 'Cat' that override the method to produce appropriate sounds.

Tasks:

•1. Define the Animal Class with a Method make_sound

class Animal:
    def make_sound(self):
        pass
Create Subclasses Dog and Cat that Override the make_sound Method

class Dog(Animal):
 def make_sound(self):
     return "Woof!"
class Cat(Animal):
 def make_sound(self):
     return "Meow!"
Implement the Sound Generation Logic for Each Subclass

A)Sound logic is implemented in the overridden make_sound methods of the subclasses.

Test the Program by Creating Instances of Dog and Cat and Calling the make_sound Method
# Create instances of Dog and Cat
dog = Dog()
cat = Cat()
# Call the make_sound method
print(dog.make_sound())  # Outputs: Woof!
print(cat.make_sound())  # Outputs: Meow!
Q6.Write a code for Restaurant Management System Using OOPS:

• Create a Menultem class that has attributes such as name, description, price, and category.

class MenuItem:
    def __init__(self, name, description, price, category):
        self.__id = id(self)
        self.name = name
        self.description = description
        self.price = price
        self.category = category
    def get_id(self):
        return self.__id
Implement Methods to Add, Update, and Remove Menu Items

class Menu:
    def __init__(self):
        self.items = []

    def add_item(self, item):
        self.items.append(item)

    def update_item(self, item_id, name=None, description=None, price=None, category=None):
        for item in self.items:
            if item.get_id() == item_id:
                if name: item.name = name
                if description: item.description = description
                if price: item.price = price
                if category: item.category = category
                break

    def remove_item(self, item_id):
        self.items = [item for item in self.items if item.get_id() != item_id]
Q)Use Encapsulation to Hide the Menu Item's Unique ID

A)The unique ID is hidden within the MenuItem class and accessed via the get_id method.

Q)Inherit from the MenuItem Class to Create FoodItem and BeverageItem Classes

class FoodItem(MenuItem):
    def __init__(self, name, description, price, category, cuisine_type):
        super().__init__(name, description, price, category)
        self.cuisine_type = cuisine_type

class BeverageItem(MenuItem):
    def __init__(self, name, description, price, category, size):
        super().__init__(name, description, price, category)
        self.size = size


# test and implimentations
# Create Menu
menu = Menu()

# Add Items
food = FoodItem("Burger", "Cheeseburger", 5.99, "Food", "American")
beverage = BeverageItem("Coke", "Coca-Cola", 1.99, "Beverage", "500ml")
menu.add_item(food)
menu.add_item(beverage)

# Update Item
menu.update_item(food.get_id(), price=6.99)

# Remove Item
menu.remove_item(beverage.get_id())

# Display Menu
for item in menu.items:
    print(f"{item.name}: ${item.price}")
7.Write a code for Hotel Management System using OOPS :

• Create a Room class that has attributes such as room number, room type, rate, and availability (private).

class Room:
    def __init__(self, room_number, room_type, rate):
        self.__id = id(self)
        self.room_number = room_number
        self.room_type = room_type
        self.rate = rate
        self.__availability = True

    def get_id(self):
        return self.__id

    def is_available(self):
        return self.__availability

    def book_room(self):
        if self.__availability:
            self.__availability = False
            return True
        return False

    def check_in(self):
        if not self.__availability:
            self.__availability = True
            return True
        return False

    def check_out(self):
        self.__availability = True
• Inherit from the Room class to create a SuiteRoom class and a StandardRoom class, each with their own specific attributes and methods.

class SuiteRoom(Room):
    def __init__(self, room_number, rate, amenities):
        super().__init__(room_number, "Suite", rate)
        self.amenities = amenities

class StandardRoom(Room):
    def __init__(self, room_number, rate):
        super().__init__(room_number, "Standard", rate)
• Implement methods to book a room, check in a guest, and check out a guest

a)Methods are already implemented in the Room class: book_room, check_in, and check_out

8.Write a code for Fitness Club Management System using OOPS:

• Create a Member class that has attributes such as name, age, membership type, and membership status (private).

class Member:
    def __init__(self, name, age, membership_type):
        self.__id = id(self)
        self.name = name
        self.age = age
        self.membership_type = membership_type
        self.__status = "Active"

    def get_id(self):
        return self.__id

    def get_status(self):
        return self.__status

    def register(self):
        self.__status = "Active"

    def renew_membership(self):
        self.__status = "Renewed"

    def cancel_membership(self):
        self.__status = "Cancelled"
Inherit from the Member Class to Create FamilyMember and IndividualMember Classes

class FamilyMember(Member):
    def __init__(self, name, age, membership_type, family_size):
        super().__init__(name, age, membership_type)
        self.family_size = family_size

class IndividualMember(Member):
    def __init__(self, name, age, membership_type):
        super().__init__(name, age, membership_type)
q)Implement Methods to Register, Renew, and Cancel Membership

a)Methods register, renew_membership, and cancel_membership are already implemented in the Member class

# Test the Implementation
# Create Members
family_member = FamilyMember("John Doe", 40, "Family", 4)
individual_member = IndividualMember("Jane Smith", 30, "Individual")

# Register Members
family_member.register()
individual_member.register()

# Renew Membership
family_member.renew_membership()

# Cancel Membership
individual_member.cancel_membership()

# Check Membership Status
print(family_member.get_status())  # Renewed
print(individual_member.get_status())  # Cancelled
Q9.Write a code for Event Management System using OOPS:

• Create an Event class that has attributes such as name, date, time, location, and list of attendees (private).

class Event:
    def __init__(self, name, date, time, location):
        self.__id = id(self)
        self.name = name
        self.date = date
        self.time = time
        self.location = location
        self.__attendees = []

    def get_id(self):
        return self.__id

    def add_attendee(self, attendee):
        self.__attendees.append(attendee)

    def remove_attendee(self, attendee):
        self.__attendees.remove(attendee)

    def get_total_attendees(self):
        return len(self.__attendees)
Inherit from the Event Class to Create PrivateEvent and PublicEvent Classes

class PrivateEvent(Event):
    def __init__(self, name, date, time, location, invite_only):
        super().__init__(name, date, time, location)
        self.invite_only = invite_only

class PublicEvent(Event):
    def __init__(self, name, date, time, location, max_capacity):
        super().__init__(name, date, time, location)
        self.max_capacity = max_capacity
Q)Implement Methods to Create, Add/Remove Attendees, and Get Total Number of Attendees

A)Methods add_attendee, remove_attendee, and get_total_attendees are already implemented in the Event class.

# Test and implementation

# Create Events
private_event = PrivateEvent("Birthday Party", "2024-08-20", "18:00", "John's House", True)
public_event = PublicEvent("Concert", "2024-09-15", "20:00", "Central Park", 500)

# Add Attendees
private_event.add_attendee("Alice")
private_event.add_attendee("Bob")
public_event.add_attendee("Charlie")

# Remove Attendee
private_event.remove_attendee("Bob")

# Get Total Attendees
print(private_event.get_total_attendees())  # 1
print(public_event.get_total_attendees())  # 1
Q10.Write a code for Airline Reservation System using OOPS:

• Create a Flight class that has attributes such as flight number, departure and arrival airports, departure and arrival times, and available seats (private).

class Flight:
    def __init__(self, flight_number, departure_airport, arrival_airport, departure_time, arrival_time, total_seats):
        self.__id = id(self)
        self.flight_number = flight_number
        self.departure_airport = departure_airport
        self.arrival_airport = arrival_airport
        self.departure_time = departure_time
        self.arrival_time = arrival_time
        self.__available_seats = total_seats

    def get_id(self):
        return self.__id

    def book_seat(self):
        if self.__available_seats > 0:
            self.__available_seats -= 1
            return True
        else:
            return False

    def cancel_reservation(self):
        if self.__available_seats < total_seats:
            self.__available_seats += 1
            return True
        else:
            return False

    def get_available_seats(self):
        return self.__available_seats
Inherit from the Flight Class to Create DomesticFlight and InternationalFlight Classes

class DomesticFlight(Flight):
    def __init__(self, flight_number, departure_airport, arrival_airport, departure_time, arrival_time, total_seats, baggage_allowance):
        super().__init__(flight_number, departure_airport, arrival_airport, departure_time, arrival_time, total_seats)
        self.baggage_allowance = baggage_allowance

class InternationalFlight(Flight):
    def __init__(self, flight_number, departure_airport, arrival_airport, departure_time, arrival_time, total_seats, meal_service):
        super().__init__(flight_number, departure_airport, arrival_airport, departure_time, arrival_time, total_seats)
        self.meal_service = meal_service
q)Implement Methods to Book a Seat, Cancel a Reservation, and Get Remaining Available Seats

a)Methods book_seat, cancel_reservation, and get_available_seats are already implemented in the Flight class.

# test and implementation
# Create Flights
domestic_flight = DomesticFlight("DF101", "JFK", "LAX", "10:00", "14:00", 150, "20 kg")
international_flight = InternationalFlight("IF202", "LHR", "JFK", "08:00", "16:00", 200, "Standard Meal")

# Book Seats
print(domestic_flight.book_seat())  # True (Seat booked)
print(international_flight.book_seat())  # True (Seat booked)

# Cancel Reservation
print(domestic_flight.cancel_reservation())  # True (Reservation cancelled)

# Get Available Seats
print(domestic_flight.get_available_seats())  # 149
print(international_flight.get_available_seats())  # 199
Q)11. Define a python module named constants.py containing constants like pi and the speed Of light.

# constants.py
PI = 3.14159
SPEED_OF_LIGHT = 299792458  # meters per second
q12. Write a python module named calculator.py containing functions for addition, subtraction, multiplication, and division.

# calculator.py
def add(a, b):
    return a + b

def subtract(a, b):
    return a - b

def multiply(a, b):
    return a * b

def divide(a, b):
    if b != 0:
        return a / b
    else:
        return "Error: Division by zero"
q13. Implement a Python package structure for a project named ecommerce, containing modules for product management and order processing.

ecommerce/
    __init__.py
    product_management.py
    order_processing.py
q14. Implement a python module named string_utils.py containing functions for string manipulation, such as reversing and capitalizing strings.

# string_utils.py
def reverse_string(s):
    return s[::-1]

def capitalize_string(s):
    return s.capitalize()
q15) Write a Python module named file_operations.py with functions for reading, writing, and appending data to a file.

# file_operations.py
def read_file(filename):
    with open(filename, 'r') as file:
        return file.read()

def write_to_file(filename, data):
    with open(filename, 'w') as file:
        file.write(data)

def append_to_file(filename, data):
    with open(filename, 'a') as file:
        file.write(data + '\n')
q16. Write a python program to create a text file named "employees.txt" and write the details Of employees, including their name, age, and salary, into the file.

# Creating employees.txt
with open("employees.txt", 'w') as file:
    file.write("Name: John Doe\nAge: 30\nSalary: $50000\n")
    file.write("Name: Jane Smith\nAge: 25\nSalary: $45000\n")
q17. Develop a python script that opens an existing text file named "inventory.txt" in read mode and displays the contents Of the file line by line.

# Reading inventory.txt
with open("inventory.txt", 'r') as file:
    for line in file:
        print(line.strip())
q18. Create a python script that reads a text file named "expenses.txt" and calculates the total amount spent on various expenses listed in the file.

# Calculating total expenses from expenses.txt
total_expenses = 0
with open("expenses.txt", 'r') as file:
    for line in file:
        try:
            expense = float(line.strip().split()[1])  # Assuming format is 'Expense: amount'
            total_expenses += expense
        except ValueError:
            pass  # Ignore lines that don't match expected format

print(f"Total expenses: ${total_expenses}")
q19. Create a python program that reads a text file named "paragraph.txt" and counts the occurrences Of each word in the paragraph, displaying the results in alphabetical order.

# Counting word occurrences in paragraph.txt
from collections import defaultdict

word_counts = defaultdict(int)
with open("paragraph.txt", 'r') as file:
    for line in file:
        words = line.strip().split()
        for word in words:
            word_counts[word.lower()] += 1

# Display results in alphabetical order
for word in sorted(word_counts):
    print(f"{word}: {word_counts[word]}")
q20. What do you mean by Measure of Central Tendency and Measures of Dispersion. How it can be calculated. a)Measure of Central Tendency:

Mean: Sum of values divided by the number of values. Median: Middle value when values are sorted. Mode: Most frequently occurring value. Measures of Dispersion:

Range: Difference between the maximum and minimum values. Variance: Average of squared differences from the mean. Standard Deviation: Square root of variance.

q21. What do you mean by skewness. Explain its types and use graph to show.

a)Skewness:

Measures asymmetry in data distribution. Positive skew: Tail on the right side of the distribution.

Negative skew: Tail on the left side of the distribution.

Graphically, positive skew means the mean > median > mode, and negative skew means the mode > median > mean.

q22. Explain PROBABILITY MASS FUNCTION (PMF) and PROBABILITY DENSITY FUNCTION (PDF), and what is the difference between them?

a)PMF: Probability distribution of discrete random variables.

PDF: Probability distribution of continuous random variables.

PMF gives probabilities for discrete outcomes, while PDF gives probabilities for continuous outcomes. PDF is also the derivative of the cumulative distribution function (CDF).

q23. What is correlation. Explain its types in detail and what are the methods of determining correlation.

Correlation:

Measures strength and direction of relationship between two variables.

Types: Pearson correlation (linear relationship), Spearman correlation (monotonic relationship), Kendall correlation (ordinal variables).

Methods: Calculate correlation coefficient (ranges from -1 to 1), visualize with scatter plots, and test significance with hypothesis tests like t-test or p-value.

Calculate coefficient of correlation between the marks obtained by 10 students in Accountancy and statistics:

student: 1 2 3 4 5 6 7 8 9 10

Accountancy 45 70 65 30 90 40 50 75 85 60

statistics 35 90 70 40 95 40 60 80 80 50

a) the coefficient of correlation (Pearson's correlation coefficient) between the marks obtained in Accountancy and Statistics for 10 students

import numpy as np

# Marks data
accountancy_marks = np.array([45, 70, 65, 30, 90, 40, 50, 75, 85, 60])
statistics_marks = np.array([35, 90, 70, 40, 95, 40, 60, 80, 80, 50])

# Calculate Pearson correlation coefficient
correlation_coefficient = np.corrcoef(accountancy_marks, statistics_marks)[0, 1]

print(f"Pearson's correlation coefficient: {correlation_coefficient}")
q25. Discuss the 4 differences between correlation and regression.

a)Purpose: Correlation measures the strength and direction of the relationship between two variables. Regression predicts the value of one variable based on another.

Nature: Correlation is symmetrical; it measures the association between variables without implying causation. Regression is directional; it establishes a predictive model.

Variables: Correlation involves two variables treated equally. Regression distinguishes between independent (predictor) and dependent (outcome) variables.

Output: Correlation produces a correlation coefficient. Regression gives an equation to predict values.

Q26. Find the most likely price at Delhi corresponding to the price of Rs. 70 at Agra from the following data: Coefficient of correlation between the prices of the two places +0.8.

A)Given a correlation coefficient of +0.8 between Agra and Delhi prices, to find the price at Delhi corresponding to Rs. 70 at Agra, use regression or the correlation coefficient directly. If Rs. 70 at Agra corresponds to a high positive correlation, a likely price at Delhi could be higher than Rs. 70.

q27) In a partially destroyed laboratory record of an analysis of correlation data, the following results only are legible: Variance of x = 9, Regression equations are: (i) 8x-10y = —66; (ii) 40x -18y = 214. What are (a) the mean values of x and y, (b) the coefficient of correlation between x and y, (c) the c of y.

import numpy as np
from sympy import symbols, Eq, solve

# (a) Mean values of x and y

# Given regression equations
# 8x - 10y = -66
# 40x - 18y = 214

# Define symbols
x, y = symbols('x y')

# Define the equations
eq1 = Eq(8*x - 10*y, -66)
eq2 = Eq(40*x - 18*y, 214)

# Solve the equations simultaneously
solution = solve((eq1, eq2), (x, y))

mean_x = solution[x]
mean_y = solution[y]

print(f"Mean of x: {mean_x}")
print(f"Mean of y: {mean_y}")

# (b) Coefficient of correlation between x and y

# Given regression coefficients
b_yx = 8 / 10
b_xy = 18 / 40

# Correlation coefficient r
r = np.sqrt(b_yx * b_xy)

print(f"Correlation coefficient: {r}")

# (c) Constant of y

# Using mean values and regression coefficient
a = mean_y - b_yx * mean_x

print(f"Constant of y: {a}")
q28. What is Normal Distribution? What are the four Assumptions of Normal Distribution? Explain in detail.

a)Normal distribution is a bell-shaped curve that's symmetric around the mean. It's often called the Gaussian distribution. The mean, median, and mode are all equal and located at the center of the distribution.

Four Assumptions of Normal Distribution:

Symmetry: The distribution is symmetric around the mean.

Equal Mean, Median, and Mode: These measures of central tendency are all the same.

Asymptotic: The tails of the distribution approach the horizontal axis but never touch it.

Defined by Mean and Standard Deviation: The distribution's shape is determined by these two parameters.

Q29.Write all the characteristics or properties of the Normal Distribution Curve.

A)Characteristics of the Normal Distribution Curve

Symmetry: The curve is symmetric around the mean.

Mean, Median, and Mode: All are equal and located at the center.

Bell-shaped: The curve has a single peak at the mean.

Asymptotic: The tails approach the horizontal axis but never touch it.

Empirical Rule: About 68% of the data falls within one standard deviation of the mean, 95% within two, and 99.7% within three.

Q30)Which of the following options are correct about Normal Distribution Curve

(a) Within a range 0.6745 of o on both sides the middle 50% of the observations occur i,e. mean *0.67450 covers 50% area 25% on each side.

a): False. The correct range for covering 50% of the area is within ±0.6745σ, not μ×0.6745.

(b) Mean ±IS.D. (i,e.p ± 10) covers 68.268% area, 34.134 % area lies on either side of the mean.

b): True. μ±1σ covers approximately 68.268% of the area under the normal distribution curve.

(c) Mean ±2S.D. (i,e. ± 20) covers 95.45% area, 47.725% area lies on either side of the mean. (c): True.μ±2σ covers approximately 95.45% of the area under the normal distribution curve

(d) Mean S.D. (i,e. p ±30) covers 99.73% area, 49.856% area lies on the either side of the mean.

d) Mean S.D. (i,e. p ±30) covers 99.73% area, 49.856% area lies on the either side of the mean.

(e) Only 0.27% area is outside the range p *3.0

e): True. Only 0.27% of the area is outside the range μ±3σ.

Q31) The mean of a distribution is 60 with a standard deviation of 10. Assuming that the distribution is normal, what percentage of items be (i) between 60 and 72, (ii) between 50 and 60, (iii) beyond 72 and (iv) between 70 and 80? a)

Given: Mean = 60, Standard Deviation = 10.

(i) Between 60 and 72:
   - Use the Z-score formula: \( Z = \frac{X - \mu}{\sigma} \)
   - Calculate Z-scores: \( Z_{60} = \frac{60 - 60}{10} = 0 \),
     \( Z_{72} = \frac{72 - 60}{10} = 1.2 \).
   - Look up Z-table or use Python's scipy.stats.norm.cdf() function.
   - Approximate percentage: Around 21.22%.

(ii) Between 50 and 60:
   - Z-scores: \( Z_{50} = \frac{50 - 60}{10} = -1 \),
     \( Z_{60} = 0 \).
   - Approximate percentage: Around 34.13%.

(iii) Beyond 72 (greater than 72):
   - Z-score for 72: \( Z_{72} = 1.2 \).
   - Use complement rule: \( 1 - \text{cdf}(Z_{72}) \).
   - Approximate percentage: Around 11.35%.

(iv) Between 70 and 80:
   - Z-scores: \( Z_{70} = \frac{70 - 60}{10} = 1 \),
     \( Z_{80} = \frac{80 - 60}{10} = 2 \).
   - Approximate percentage: Around 31.73%.
.
q32. 15000 students sat for an examination. The mean marks was 49 and the distribution of marks had a standard deviation of 6. Assuming that the marks were normally distributed what proportion of students scored (a) more than 55 marks, (b) more than 70 marks

Given: Mean = 49, Standard Deviation = 6, Total students = 15000.

(a) Proportion of students scoring more than 55 marks:
   - Z-score for 55: \( Z_{55} = \frac{55 - 49}{6} = 1 \).
   - Use complement rule: \( 1 - \text{cdf}(Z_{55}) \).
   - Approximate percentage: Around 15.87%.

(b) Proportion of students scoring more than 70 marks:
   - Z-score for 70: \( Z_{70} = \frac{70 - 49}{6} = 3.5 \).
   - Use complement rule: \( 1 - \text{cdf}(Z_{70}) \).
   - Approximate percentage: Around 0.03%.
If the height of 500 students are normally distributed with mean 65 inch and standard deviation 5 inch. How many students have height : a) greater than 70 inch. b) between 60 and 70 inch.
Given: Mean = 65 inches, Standard Deviation = 5 inches, Total students = 500.

(a) Number of students with height greater than 70 inches:
   - Z-score for 70 inches: \( Z_{70} = \frac{70 - 65}{5} = 1 \).
   - Use the complement rule: \( 1 - \text{cdf}(Z_{70}) \).
   - Approximate percentage: Around 15.87%.
   - Number of students: \( \text{Total students} \times \text{Percentage} = 500 \times 0.1587 = 79.35 \).

   Since you can't have a fraction of a student, round to the nearest whole number:
   - Number of students greater than 70 inches: Approximately 79.

(b) Number of students with height between 60 and 70 inches:
   - Z-score for 60 inches: \( Z_{60} = \frac{60 - 65}{5} = -1 \).
   - Z-score for 70 inches: \( Z_{70} = \frac{70 - 65}{5} = 1 \).
   - Calculate the area between these two Z-scores using the difference of cdf values:
     \( \text{cdf}(Z_{70}) - \text{cdf}(Z_{60}) \).
   - Approximate percentage: Around 68.27%.
   - Number of students: \( 500 \times 0.6827 = 341.35 \).

   Round to the nearest whole number:
   - Number of students between 60 and 70 inches: Approximately 341.
35.A random sample of size 25 from a population gives the sample standard derivation to be 9.0. Test the hypothesis that the population standard derivation is 10.5. Hint(use chi- square distribution).

statistical hypothesis a)Statistical hypothesis is a statement o r assumption about the population parameters, tested using statistical methods to determine if there is enough evidence to reject or fail to reject the null hypothesis (H₀).

Errors in Hypothesis Testing: Type I Error: Occurs when we reject the null hypothesis (H₀) when it is actually true. It's a false positive.

Type II Error: Occurs when we fail to reject the null hypothesis (H₀) when it is actually false. It's a false negative.

Sample Explanation: Sample: A subset of individuals or objects selected from a larger population to represent it in a study or experiment.

Large Samples vs. Small Samples:

Large Samples: Typically have more than 30 observations. They tend to provide more reliable estimates of population parameters and are less affected by random fluctuations.

Small Samples: Usually have fewer than 30 observations. They can still provide insights but are more susceptible to random variability, making generalizations to the population more challenging.

Q37)100 students of a PW 101 obtained the following grades in Data Science paper : Grade : [A,B, C, D, E]

Total Frequency : [15,17, 30, 22, 16, 100]

Using the X(sigma)2 test , examine the hypothesis that the distribution of grades is uniform.

a)x`Given Data:

Grades: A, B, C, D, E

Frequencies: 15, 17, 30, 22, 16

Total students: 100

Calculate Expected Frequencies:

If the distribution were uniform, each grade would have an expected frequency of 100/5=20.

Set up Hypotheses:

Null Hypothesis (H₀): The distribution of grades is uniform.

Alternative Hypothesis (H₁): The distribution of grades is not uniform.

Compute Chi-square Statistic:

𝜒2=∑(𝑂𝑖−𝐸𝑖)2/Ei, where Oi is the observed frequency and Ei is the expected frequency for each grade.

Degrees of Freedom:

Degrees of freedom (df) = Number of categories - 1 = 5 - 1 = 4.

Compare with Critical Value: Use a Chi-square table or function (like scipy.stats.chi2) to find the critical value for χ2 with 4 degrees of freedom at a chosen significance level (e.g., 0.05).

Q36) Not Available in assignment PDF

Double-click (or enter) to edit

q38.Anova Test: TO study the performance Of three detergents and three different water temperatures the following whiteness readings were obtained with specially designed equipment.

Water temp | Detergents A | Detergents B | Detergents C

Cold Water | 57 | 55 | 67

Worm Water | 49 | 52 | 68

Hot Water | 54 | 46 | 58

Data:

Cold Water: [57, 55, 67]

Warm Water: [49, 52, 68]

Hot Water: [54, 46, 58]

Hypotheses:

H₀: No difference in mean whiteness among detergents and water temperatures. H₁: At least one mean whiteness is different

import pandas as pd
import scipy.stats as stats

# Data
data = {
    'Detergent A': [57, 49, 54],
    'Detergent B': [55, 52, 46],
    'Detergent C': [67, 68, 58]
}

df = pd.DataFrame(data, index=['Cold Water', 'Warm Water', 'Hot Water'])

# Reshape data for ANOVA
df_melt = pd.melt(df.reset_index(), id_vars=['index'], value_vars=['Detergent A', 'Detergent B', 'Detergent C'])
df_melt.columns = ['Water_Temperature', 'Detergent', 'Whiteness']

# ANOVA test
anova_result = stats.f_oneway(
    df_melt[df_melt['Detergent'] == 'Detergent A']['Whiteness'],
    df_melt[df_melt['Detergent'] == 'Detergent B']['Whiteness'],
    df_melt[df_melt['Detergent'] == 'Detergent C']['Whiteness']
)

anova_result
Q39.How would you create a basic Flask route that displays "Hello, World!" on the homepage?

# !pip install Flask
# Import Flask
from flask import Flask

# Create Flask app
app = Flask(__name__)

# Define route for homepage
@app.route('/')
def home():
    return "Hello, World!"

# Run the app
if __name__ == '__main__':
    app.run()
q40.Explain how to set up a Flask application to handle form submissions using POST requests.

from flask import Flask, request, render_template_string

app = Flask(__name__)

# Define the form template
form_template = '''
<!doctype html>
<html>
<body>
    <form method="POST" action="/">
        <input type="text" name="name">
        <input type="submit">
    </form>
</body>
</html>
'''

# Define the route to display the form
@app.route('/', methods=['GET', 'POST'])
def form():
    if request.method == 'POST':
        name = request.form['name']
        return f"Hello, {name}!"
    return render_template_string(form_template)

# Run the app
if __name__ == '__main__':
    app.run()
q41.Write a Flask route that accepts a parameter in the URL and displays it on the page.

from flask import Flask

app = Flask(__name__)

# Define the route with a parameter
@app.route('/hello/<name>')
def hello(name):
    return f"Hello, {name}!"

# Run the app
if __name__ == '__main__':
    app.run()
Q42.How can you implement user authentication in a Flask application?

!pip install Flask Flask-Login
from flask import Flask, render_template_string, redirect, url_for, request
from flask_login import LoginManager, UserMixin, login_user, login_required, logout_user, current_user

app = Flask(__name__)
app.secret_key = 'secretkey'
login_manager = LoginManager()
login_manager.init_app(app)

# User class
class User(UserMixin):
    def __init__(self, id):
        self.id = id

# User loader
@login_manager.user_loader
def load_user(user_id):
    return User(user_id)

# Login route
@app.route('/login', methods=['GET', 'POST'])
def login():
    if request.method == 'POST':
        user = User(request.form['username'])
        login_user(user)
        return redirect(url_for('protected'))
    return '''
    <form method="POST" action="/login">
        <input type="text" name="username">
        <input type="submit">
    </form>
    '''

# Protected route
@app.route('/protected')
@login_required
def protected():
    return f'Logged in as: {current_user.id}'

# Logout route
@app.route('/logout')
@login_required
def logout():
    logout_user()
    return 'Logged out!'

# Run the app
if __name__ == '__main__':
    app.run()
Q43.Describe the process of connecting a Flask app to a SQLite database using SQLAIchemy.

!pip install Flask-SQLAlchemy
from flask import Flask
from flask_sqlalchemy import SQLAlchemy

app = Flask(__name__)
app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///test.db'
db = SQLAlchemy(app)

# Define a model
class User(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    username = db.Column(db.String(80), unique=True, nullable=False)

# Create the database and tables
with app.app_context():
    db.create_all()

# Run the app
if __name__ == '__main__':
    app.run()
q44.How would you create a RESTful API endpoint in Flask that returns JSON data?

!pip install Flask
from flask import Flask, jsonify

app = Flask(__name__)

@app.route("/api/data", methods=['GET'])
def get_data():
    data = {'key': 'value', 'number': 42}
    return jsonify(data)

# Run the app
if __name__ == '__main__':
    app.run()
Q45.Explain how to use Flask—WTF to create and validate forms in a Flask application.

!pip install Flask-WTF
from flask import Flask, render_template_string, request
from flask_wtf import FlaskForm
from wtforms import StringField, SubmitField
from wtforms.validators import DataRequired

app = Flask(__name__)
app.secret_key = 'secretkey'

class MyForm(FlaskForm):
    name = StringField('Name', validators=[DataRequired()])
    submit = SubmitField('Submit')

@app.route('/', methods=['GET', 'POST'])
def form():
    form = MyForm()
    if form.validate_on_submit():
        return f"Hello, {form.name.data}!"
    return render_template_string('''
    <form method="POST">
        {{ form.hidden_tag() }}
        {{ form.name.label }} {{ form.name() }}
        {{ form.submit() }}
    </form>
    ''', form=form)

# Run the app
if __name__ == '__main__':
    app.run()
Q46.How can you implement file uploads in a Flask application?

!pip install Flask
from flask import Flask, request, render_template_string

app = Flask(__name__)
app.config['UPLOAD_FOLDER'] = '/path/to/upload'

@app.route('/', methods=['GET', 'POST'])
def upload_file():
    if request.method == 'POST':
        file = request.files['file']
        if file:
            file.save(os.path.join(app.config['UPLOAD_FOLDER'], file.filename))
            return 'File uploaded successfully'
    return '''
    <form method="POST" enctype="multipart/form-data">
        <input type="file" name="file">
        <input type="submit">
    </form>
    '''

# Run the app
if __name__ == '__main__':
    app.run()
Q47.Describe the Steps to create a Flask blueprint and why you might use one.

!pip install Flask
from flask import Flask, Blueprint

# Create a blueprint
my_blueprint = Blueprint('my_blueprint', __name__)

@my_blueprint.route('/hello')
def hello():
    return "Hello from blueprint!"

# Create Flask app
app = Flask(__name__)
app.register_blueprint(my_blueprint, url_prefix='/blueprint')

# Run the app
if __name__ == '__main__':
    app.run()
use a blueprint Organizes code into modular components.

Makes the app easier to manage and scale.

Q48.How would you deploy a Flask application to a production server using Gunicorn and Nginx?

# Install Gunicorn:
pip install gunicorn
# Run Flask app with Gunicorn:
gunicorn -w 4 myapp:app
# Nginx configuration:
# Edit /etc/nginx/sites-available/myapp:
server {
    listen 80;
    server_name your_domain;

    location / {
        proxy_pass http://127.0.0.1:8000;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }
}
# Enable Nginx site:
sudo ln -s /etc/nginx/sites-available/myapp /etc/nginx/sites-enabled
sudo systemctl restart nginx
Q49. Make a fully functional web application using flask, Mangodb. Signup,Signin page.And after successfully login Say hello Geeks message at webpage.

!pip install Flask Flask-PyMongo Flask-Bcrypt Flask-Login
# Flask app with MongoDB:
from flask import Flask, render_template_string, request, redirect, url_for
from flask_pymongo import PyMongo
from flask_bcrypt import Bcrypt
from flask_login import LoginManager, UserMixin, login_user, login_required, logout_user, current_user

app = Flask(__name__)
app.config['MONGO_URI'] = 'mongodb://localhost:27017/mydatabase'
app
50.Machine Learning:

• What is the difference between Series & Dataframes .

-*Series: A one-dimensional labeled array capable of holding any data type.

*DataFrame: A two-dimensional labeled data structure with columns of potentially different types.

• Create a database name Travel_planner in mysql ,and create a table name bookings in that which having attributes (user_id INT, flight_id INT, activity_id DATE) fill with some dummy value -Now you have to read the content of this table using pandas as dataframe.Show the output.

CREATE DATABASE Travel_planner;
USE Travel_planner;
CREATE TABLE bookings (
    user_id INT,
    flight_id INT,
    activity_date DATE
);
INSERT INTO bookings (user_id, flight_id, activity_date) VALUES 
(1, 101, '2023-07-01'),
(2, 102, '2023-07-02'),
(3, 103, '2023-07-03');
!pip install pymysql sqlalchemy pandas

import pandas as pd
from sqlalchemy import create_engine

# Create engine
engine = create_engine('mysql+pymysql://username:password@localhost/Travel_planner')

# Read table into DataFrame
df = pd.read_sql('SELECT * FROM bookings', engine)
print(df)
• Difference between loc and iloc.

- *loc: Access a group of rows and columns by labels or a boolean array.

*iloc: Access a group of rows and columns by integer positions (indices).

• What is the difference between supervised and unsupervised learning?

- *Supervised Learning: The model is trained on labeled data (input-output pairs).

*Unsupervised Learning: The model is trained on unlabeled data and finds hidden patterns or intrinsic structures.

• Explain the bias-variance tradeoff.

-*Bias: Error due to overly simplistic models, missing patterns.

*Variance: Error due to overly complex models, capturing noise.

*Tradeoff: Aim to find a balance; too much bias misses patterns, too much variance overfits.

• What are precision and recall? How are they different from accuracy?

- **Precision: True Positives/ True Positives+False Positives

**Recall: True Positives/True Positive+False Negatives

**Accuracy: True Positives+True Negatives/Total Samples

**Difference: Precision measures correctness of positive predictions; recall measures how well positives are identified.

• What is overfitting and how can it be prevented?

-**Overfitting: Model learns noise, not just patterns.

**Prevention: Use cross-validation, regularization, pruning, simpler models, more data.

• Explain the concept Of cross-validation.

-Concept: Split data into k-folds, train on k-1 folds, validate on remaining fold. Repeat k times, average results.

• What is the difference between a classification and a regression problem?

-*Classification: Predict categorical outcomes (e.g., spam/not spam).

*Regression: Predict continuous outcomes (e.g., house prices).

• Explain the concept Of ensemble learning.

=Concept: Combine multiple models to improve performance (e.g., bagging, boosting).

• What is gradient descent and how does it work?

= *Concept: Optimization algorithm to minimize loss function.

*How it Works: Update model parameters iteratively by moving in the direction of negative gradient.

• Describe the difference between batch gradient descent and stochastic gradient descent.

=*Batch: Uses all training data at once for updates.

*Stochastic: Uses one training sample per update, faster but noisier.

• What is the Curse Of dimensionality in machine learning?

=Concept: High-dimensional spaces make learning and generalizing difficult due to sparse data

• Explain the difference between Ll and L2 regularization.

-*L1 (Lasso): Adds absolute values of coefficients to loss function, can produce sparse models.

*L2 (Ridge): Adds squared values of coefficients to loss function, keeps all coefficients small.

• What is a confusion matrix and how is it used?

=Concept: Table to evaluate performance of classification models. Shows true vs predicted classes

• Define AUC-ROC curve.

=AUC: Area under the ROC curve, measures classifier performance.

ROC Curve: Plots true positive rate vs false positive rate across thresholds.

• Explain the k-nearest neighbors algorithm.

=Concept: Classify a data point based on the majority class of its k nearest neighbors.

How it Works: Calculate the distance between points, find the nearest k neighbors, and assign the majority label.

• Explain the basic concept of a Support Vector Machine (SVM).

*Concept: Find the optimal hyperplane that separates classes in a dataset.

*How it Works: Maximize the margin between the closest points (support vectors) of different classes

• How does the kernel trick work in SVM?

= Use kernel functions (e.g., linear, polynomial, RBF) to implicitly map input features

• What are the different types of kernels used in SVM and when would you use each? - *Linear: Use when data is linearly separable.

*Polynomial: Use when data has polynomial relationships.

*RBF (Gaussian): Use when data has complex boundaries.

• What is the hyperplane in SVM and how is it determined? =-Concept: The decision boundary that separates different classes.

-Determination: Found by maximizing the margin between the closest points of the classes.

• What are the pros and cons of using a Support Vector Machine (SVM)?

= -Pros: Effective in high-dimensional spaces, robust to overfitting with proper regularization.

-Cons: Computationally intensive, less effective on large datasets with noise

• Explain the difference between a hard margin and a soft margin SVM.

= *Hard Margin: No misclassifications allowed, only works with linearly separable data.

*Soft Margin: Allows some misclassifications, uses a regularization parameter to balance margin width and misclassification.

• Describe the process of constructing a decision tree.

=Process: Split data recursively based on feature values to create branches, stop when leaves are pure or other stopping criteria are met.

• Describe the working principle of a decision tree.

=Concept: Use a tree structure to make decisions based on feature values, starting from the root and moving to leaves.

• What is information gain and how is it used in decision trees?

=-Concept: Measure of how well a feature separates the classes.

-Usage: Select features with the highest information gain to split nodes.

• Explain Cini impurity and its role in decision trees.

*Concept: Measure of impurity or disorder in a dataset.

*Role: Used to select features by minimizing impurity in splits.

• What are the advantages and disadvantages of decision trees?

=*Advantages: Easy to understand, interpretable, handles both numerical and categorical data.

*Disadvantages: Prone to overfitting, sensitive to small data changes.

• How do random forests improve upon declsion trees?

= -Improvement: Combine multiple trees to reduce overfitting and improve generalization.

-How it Works: Create multiple trees using bootstrapped subsets of data and aggregate their predictions

• How does a random forest algorithm work? =1.Data Sampling: Random subsets of data created using bootstrapping.

2.Tree Construction: Multiple decision trees built with random feature subsets.

V3.oting: Trees vote on classification or average predictions for regression.

4.Final Prediction: Combines tree outputs for robust predictions.

• What is bootstrapping in the context of random forests?

=-Definition: Sampling technique with replacement to create multiple datasets.

-Purpose: Generates diverse subsets for training individual decision trees in Random Forests.

• Explain the concept of feature importance in random forests.

=Definition: Measures impact of each feature on model predictions.

Calculation: Analyzes how much each feature contributes to reducing prediction error across all trees.

• What are the key hyperparameters of a random forest and how do they affect the model?

=*Number of Trees: Increases model complexity and computational cost.

*Max Features: Controls the number of features considered for splitting.

*Tree Depth: Influences model complexity and overfitting

• Describe the logistic regression model and its assumptions.

=-Model: Linear regression for binary classification.

-Assumptions: Linear relationship between features and log-odds of the outcome.

• How does logistic regression handle binary classification problems?

=Output: Predicts probability of a binary outcome.

Decision: Classifies based on threshold (typically 0.5)

• What is the sigmoid function and how is it used in logistic regression?

=*Definition: S-shaped curve transforming input to a range between 0 and 1.

*Use: Converts logistic regression output into probabilities

• Explain the concept of the cost function in logistic regression.

=-Purpose: Measures model performance by penalizing incorrect predictions.

-Optimization: Minimizes cost using techniques like gradient descent

• How can logistic regression be extended to handle multiclass classification?

=One-vs-Rest: Trains multiple binary classifiers, one for each class.

Softmax Function: Outputs probabilities across multiple classes.

• What is the difference between Ll and L2 regularization in logistic regression?

=*L1 (Lasso): Penalizes absolute weights, promoting sparsity.

*L2 (Ridge): Penalizes squared weights, shrinking coefficients towards zero

• What is XGBoost and how does it differ from other boosting algorithms?

=*Definition: Gradient boosting library for optimized performance.

*Advantages: Handles large datasets, supports regularization, and manages missing values.

• Explain the concept of boosting in the context of ensemble learning.

=-Purpose: Combines weak learners sequentially to improve prediction accuracy.

-Process: Adjusts weights of misclassified instances to prioritize learning from errors.

• How does XGBoost handle missing values?

*Treatment: Automatically handles missing values during training.

*Process: Learns default directions for missing data, reducing prediction bias.

• What are the key hyperparameters in XGBoost and how do they affect model performance?

=1.Number of Trees: Controls the number of boosting rounds.

2.Learning Rate (eta): Scales the contribution of each tree.

3.Tree Depth (max_depth): Limits the depth of each tree.

4.Subsample: Fraction of training data used per tree.

5.Column Subsampling (colsample_bytree): Fraction of features used per tree.

• Describe the process of gradient boosting in XGBoost.

=Initialization: Starts with a simple model (usually a single leaf).

Iterative Improvement: Sequentially adds new models to correct errors made by existing models.

Gradient Descent: Optimizes a loss function by minimizing errors in predictions.

• What are the advantages and disadvantages of using XGBoost? = Advantage

*High Performance: Fast execution speed and scalability.

*Regularization: Reduces overfitting with regularization techniques.

Disadvantage *Complexity: Requires careful tuning of hyperparameters.

*Computationally Intensive: Can be resource-intensive, especially with large datasets
Q1.1: Write the Answer to these questions.

• What is the difference between static and dynamic variables in python?

ans) Static Variables Definition: Static variables, also known as class variables, are variables that are shared among all instances of a class.

1.Scope: They are defined within a class but outside any instance methods.

Dynamic Variables Definition: Dynamic variables, often referred to as instance variables, are unique to each instance of a class.

1.Scope: They are defined within methods, usually the' init' method, and are prefixed with 'self' to indicate they belong to the instance.

• Explain the purpose of "pop","popitem", and "clear()" in a dictionary with suitable examples.

pop Method Purpose: The pop method removes the specified key and returns the corresponding value. If the key is not found, it raises a KeyError, unless a default value is provided. ex:

print(my_dict.pop('b'))  # Output: 2
print(my_dict)  # Output: {'a': 1, 'c': 3}

print(my_dict.pop('d', 'Not Found'))  # Output: Not Found
print(my_dict)  # Output: {'a': 1, 'c': 3}
popitem Method Purpose: The popitem method removes and returns the last key-value pair as a tuple. If the dictionary is empty, it raises a KeyError.

print(my_dict.popitem())  # Output: ('c', 3)
print(my_dict)  # Output: {'a': 1, 'b': 2}
clear Method Purpose: The clear method removes all items from the dictionary, leaving it empty.

https://colab.research.google.com/drive/1hjgOanZBKDzd2bZ6wRMluW1u3AfxvCNn#scrollTo=-lPY-epTr3U9&line=1&uniqifier=1
(If you get any issue with reading it visit google colab using above link)
my_dict.clear()
print(my_dict)  # Output: {}
• What do you mean by FrozenSet? Explain it with suitable examples.

A frozenset in Python is an immutable set, meaning its elements cannot be modified after creation. It can be used as dictionary keys or set elements because it is hashable.

fs = frozenset([1, 2, 3])
print(fs)  # Output: frozenset({1, 2, 3})

my_dict = {fs: "Group 1"}
print(my_dict[fs])  # Output: Group 1
• Differentiate between mutable and immutable data types in python and give examples of mutable and immutable data types.

Mutable Data Types: List: lst = [1, 2, 3] Dictionary: dct = {'a': 1, 'b': 2} Set: st = {1, 2, 3} Immutable Data Types: string: s = "hello" Tuple: tpl = (1, 2, 3) Frozenset: fs = frozenset([1, 2, 3])

lst = [1, 2, 3]
lst.append(4)
print(lst)  # Output: [1, 2, 3, 4]

# Immutable
s = "hello"
# s[0] = 'H'  # This will raise an error
• What is init ? explain with an example.

init is a special method in Python classes, called a constructor, which is automatically invoked when a new instance of the class is created. It initializes the instance's attributes

    def __init__(self, name, age):
        self.name = name
        self.age = age

p1 = Person("Alice", 30)
print(p1.name)  # Output: Alice
print(p1.age)   # Output: 30
• What is docstring in Python?Explain with an example.

A docstring in Python is a string literal that appears right after the definition of a function, method, class, or module. It is used to document the purpose and behavior of the component.

    """This function greets the person whose name is passed as an argument."""
    return f"Hello, {name}!"

print(greet.__doc__)  # Output: This function greets the person whose name is passed as an argument.
• What are unit tests in Python?

Unit tests in Python are a way to test small parts of your code to make sure they work correctly. They help you catch bugs early and ensure that changes to your code don't break existing functionality. Here's a simple example using the unittest module:


def add(a, b):
    return a + b

class TestAddFunction(unittest.TestCase):
    def test_add(self):
        self.assertEqual(add(2, 3), 5)  # Check if add(2, 3) returns 5
        self.assertEqual(add(-1, 1), 0)  # Check if add(-1, 1) returns 0

if __name__ == '__main__':
    unittest.main()
• What is break, continue and pass in python? break Purpose: Terminates the nearest enclosing loop (for loop, while loop, or nested loops).

for i in range(5):
    if i == 3:
        break
    print(i)
# Output: 0, 1, 2
continue Purpose: Skips the current iteration of a loop and proceeds to the next iteration.

    if i == 2:
        continue
    print(i)
# Output: 0, 1, 3, 4
pass Purpose: Does nothing and acts as a placeholder where syntactically required.

    if i == 2:
        pass  # Placeholder, does nothing
    print(i)
# Output: 0, 1, 2, 3, 4
• What is the use of self in Python?

self is used inside class methods to refer to the instance (object) itself. It allows methods to access and modify instance attributes.

class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age

    def greet(self):
        return f"Hello, my name is {self.name} and I am {self.age} years old."

# Creating an instance of Person
p = Person("Alice", 30)
print(p.greet())  # Output: Hello, my name is Alice and I am 30 years old.
• What are globa , protected and private attributes in Python?

Global Attributes: Variables defined at the module level, accessible throughout the module.


def some_function():
    print(global_var)

some_function()  # Output: 10
Protected Attributes: Conventionally marked with a single leading underscore (_). It suggests that the attribute should be used within its class or module.

class MyClass:
    def __init__(self):
        self._protected_var = 20

    def get_protected_var(self):
        return self._protected_var

obj = MyClass()
print(obj.get_protected_var())  # Output: 20
Private Attributes: Indicated by a double leading underscore (__). It triggers name mangling to make the attribute less accessible from outside the class.

    def __init__(self):
        self.__private_var = 30

    def get_private_var(self):
        return self.__private_var

obj = MyClass()
# Directly accessing __private_var will raise an AttributeError
print(obj.get_private_var())  # Output: 30
• What are modules and packages in python?

Modules: Modules in Python are files containing Python code that define functions, classes, and variables. They help organize code into reusable units, making it easier to manage and maintain.

# math_operations.py
def add(a, b):
    return a + b

# main.py
import math_operations

print(math_operations.add(5, 3))  # Output: 8
Packages: Packages are directories containing multiple Python modules along with a special init.py file. They provide a way to structure and namespace Python's module namespace, allowing for hierarchical organization of code.

# my_package/module1.py
def func1():
    print("Function 1")

# my_package/module2.py
def func2():
    print("Function 2")

# main.py
from my_package import module1, module2

module1.func1()  # Output: Function 1
module2.func2()  # Output: Function 2
• What are lists and tuples? What is the key difference between the two?

Lists: Mutable sequences of elements, defined with square brackets [ ].

Tuples: Immutable sequences of elements, defined with parentheses ( ).

my_list = [1, 2, 3]

# Tuple example
my_tuple = (1, 2, 3)
• What is an Interpreted language & dynamically typed language?Write 5 differences between them.

Interpreted vs Dynamically Typed Language:

Interpreted Language: Code is executed line by line without compiling (e.g., Python). Dynamically Typed Language: Variable types are determined at runtime, allowing flexibility but potentially leading to runtime errors.

x = 5  # Integer
x = "hello"  # String
• What are Dict and List comprehensions?

Dict and List Comprehensions:

List Comprehension: Concise way to create lists based on existing lists. Dict Comprehension: Similar to list comprehension but creates dictionaries

squares = [x**2 for x in range(5)]

# Dict comprehension
square_dict = {x: x**2 for x in range(5)}
• What are decorators in Python? Explain it with an example.Write down its use cases.

Decorators:

Functions that modify the behavior of other functions or methods without changing their code. Used for adding functionalities like logging, timing, or access control.

    def wrapper():
        print("Something is happening before the function is called.")
        func()
        print("Something is happening after the function is called.")
    return wrapper

@my_decorator
def say_hello():
    print("Hello!")

say_hello()
• How is memory managed in Python?

Memory Management in Python:

Handled automatically by Python's memory manager using techniques like reference counting and garbage collection. Ensures efficient allocation and deallocation of memory.

• What is lambda in python? Why is it used?

Lambda Functions:

Small anonymous functions defined with lambda keyword. Used for short functions where def syntax is overly verbose

add = lambda x, y: x + y
print(add(3, 5))  # Output: 8
• Explain split() and join() functions in Python?

split(): Splits a string into a list of substrings based on a delimiter.

join(): Concatenates elements of an iterable into a string, with a specified separator.

sentence = "Hello, world!"
words = sentence.split(", ")  # Output: ['Hello', 'world!']
new_sentence = "-".join(words)  # Output: 'Hello-world!'
• What are iterators , iterable & generators in Python?

Iterable: Any object capable of returning its members one at a time (e.g., lists, tuples).

Iterator: Object used to iterate through an iterable using iter() and next() methods.

Generators: Functions that generate a sequence of values lazily, using yield instead of return.

def square_numbers(n):
    for i in range(n):
        yield i ** 2

my_gen = square_numbers(5)
print(list(my_gen))  # Output: [0, 1, 4, 9, 16]
• What is the difference between xrange and range in python?

range: Returns a list of numbers and stores them in memory.

xrange: Generates numbers on-the-fly, using less memory, but available only in Python 2 (in Python 3, range behaves like xrange).

for i in xrange(5):
    print(i)
• Pillars of Oops.

Pillars of OOPs:

Encapsulation: Bundling of data and methods that operate on the data.

Inheritance: Ability of a class to inherit properties and methods from another class.

Polymorphism: Ability to use a single interface for different data types or classes.

Abstraction: Hiding complex implementation details and showing only relevant information.

• How will you check if a class is a child Of another class?

Use issubclass() function to check if a class is a subclass of another class.

    pass

class Child(Parent):
    pass

print(issubclass(Child, Parent))  # Output: True
• How does inheritance work in python? Explain all types of inheritance with an example.

Inheritance in Python:

Mechanism where a new class derives attributes and methods from an existing class.

Types include single, multiple, multilevel, and hierarchical inheritance.

class Parent:
    def show(self):
        print("Parent method")

class Child(Parent):
    pass

obj = Child()
obj.show()  # Output: Parent method
• What is encapsulation? Explain it with an example.

Encapsulation is the bundling of data and methods that operate on the data into a single unit (class). Ex:

    def __init__(self, brand):
        self.brand = brand
        self.__mileage = 0  # Private attribute

    def drive(self):
        self.__mileage += 10

my_car = Car("Toyota")
my_car.drive()
# Accessing private attribute directly will raise an AttributeError
• What is polymorphism? Explain it with an example.

Polymorphism allows methods to be written in a way that they can take multiple forms or implementations. Ex:

    def sound(self):
        print("Bark")

class Cat:
    def sound(self):
        print("Meow")

def make_sound(animal):
    animal.sound()

make_sound(Dog())  # Output: Bark
make_sound(Cat())  # Output: Meow
Q1.2. Which of the following identifier names are invalid and why? Serial_no. 1st_Room Hundred$ Total_Marks total-Marks Total Marks True _ percentag

1.serial_no. -- it's valid identifier

2.1st_room -- it's invalid identifier due to having number at the begining.

3.Hundred$ - it's valid identifier

4.Total_Marks -- it's valid identifier

5.total-marks -- it's invalid identifier due to hyphens (-) are not allowed

6.Total Marks -- it's invalid identifier due to space are not allowed

7.True -- it's invalid identifier due to Keywords are not allowed

8._percentag - it's valid identifier

Question 1.3. name = ('Mohan•, "dash", "karam•, do the following operations in this list; a) add an element "freedom_fighter" in this list at the 0th index.

name_list = list(name)
name_list.insert(0, "freedom_fighter")
name = tuple(name_list)

print(name)  # Output: ('freedom_fighter', 'Mohan', 'dash', 'karam')
b) find the output of the following rand explain how?

name = ["freedeomFighter","Bapuji","MOhan","dash", "karam","chandra","gandhi"] length1 = len((name[-len(name)+1:-1:2])) length2 = len((name[-len(name)+1:-1])) print(length1+length2)

name = ["freedeomFighter", "Bapuji", "MOhan", "dash", "karam", "chandra", "gandhi"]
length1 = len(name[1:-1:2])
length2 = len(name[1:-1])
print(length1 + length2)  # Output: 8
The code calculates lengths of two slices of the list and sums them.

length1 is 3 and length2 is 5. The sum is 8.

c) Add Two more elements in the name ["Netaji","Bose"] at the end of the list

name = ["freedeomFighter", "Bapuji", "MOhan", "dash", "karam", "chandra", "gandhi"]
name.extend(["Netaji", "Bose"])
print(name)
d) What will be the value of temp: name = ["Bapuji","dash","karam","chandra","gandhi","mohan"] temp = name[-1] name[-1] =name[0] name[0] = temp print(name)

ans) (outpur) name = ['mohan', 'dash', 'karam', 'chandra', 'gandhi', 'Bapuji']

Question 1.4.Find the output of the following.

animal = ["Human","cat","mat","cat","rat","Human"] print(animal.count('Human')) print(animal.index('rat')) print(len(animal))

print(animal.count('Human')) #output 2
print(animal.index('rat')) #output 4
print(len(animal)) #output 6
Q1.5) tuple1 = (10,20,"apple",3.4,"a",["master","ji"],("sita","geeta",22),[{"roll_no":1},{"name":"Navneet"}])

a)print(len(tuple1)) b)print(tuple1[-1][-1]["name"]) c)fetch the value of rool_no from this tuple. d)print(tuple1[-3][1]) e)fetch the element "22" from this tuple.


# a) Print length of the tuple
print(len(tuple1))  # Output: 8

# b) Print the value associated with the key "name"
print(tuple1[-1][-1]["name"])  # Output: Navneet

# c) Fetch the value of "roll_no"
print(tuple1[-1][0]["roll_no"])  # Output: 1

# d) Print the second element of the seventh item in the tuple
print(tuple1[-3][1])  # Output: geeta

# e) Fetch the element "22" from the tuple
print(tuple1[-3][-1])  # Output: 22
1.6. Write a program to display the appropriate message as per the color Of signal(RED-Stop/YeIIow-Stay/Green-Go) at the road crossing.

signal = input("Enter the signal color (RED/Yellow/Green): ").strip().lower()

if signal == 'red':
    print("Stop")
elif signal == 'yellow':
    print("Stay")
elif signal == 'green':
    print("Go")
else:
    print("Invalid color")
1.7. Write a program to create a simple calculator performing only four basic perations(+,-,/,* ).

def calculator(a, b, operation):
    if operation == '+':
        return a + b
    elif operation == '-':
        return a - b
    elif operation == '*':
        return a * b
    elif operation == '/':
        return a / b
    else:
        return "Invalid operation"

a = float(input("Enter first number: "))
b = float(input("Enter second number: "))
operation = input("Enter operation (+, -, *, /): ")

result = calculator(a, b, operation)
print("The result is:", result)
1.8. Write a program to find the larger of the three pre- specified numbers using temary operators.

a, b, c = 5, 10, 3
largest = a if a > b and a > c else b if b > c else c
print("The largest number is:", largest)
1.9. Write a program to find the factors Of a whole number using a while loop.

number = int(input("Enter a whole number: "))
i = 1

while i <= number:
    if number % i == 0:
        print(i)
    i += 1
1.10. Write a program to find the sum of all the positive numbers entered by the user. As soon as the user enters a negative number, stop taking in any further input from the user and display the sum .

total = 0

while True:
    num = int(input("Enter a number: "))
    if num < 0:
        break
    total += num

print("The sum is:", total)
1.11. Write a program to find prime numbers between 2 to 100 using nested for loops.

for num in range(2, 101):
    is_prime = True
    for i in range(2, int(num ** 0.5) + 1):
        if num % i == 0:
            is_prime = False
            break
    if is_prime:
        print(num)
1.12. Write the programs for the following: Screenshot 2024-07-13 141144.png

(if image not visible)

Criteria Grade
percentage > 85 A

percentage < 85 && percentage >= 75 B

percentage < 75 && percentage >= 50 c

percentage > 30 && percentage 50 D

percentage `<30 Reappear

Q)Accept and Display Marks of Five Subjects

a)Allows the user to input marks for five subjects and stores them in a list marks, then prints the list.

# Accept marks of five subjects from the user
marks = []
for i in range(5):
    subject_marks = float(input(f"Enter marks for subject {i+1}: "))
    marks.append(subject_marks)

# Display the marks of all subjects
print("Marks obtained in five subjects:", marks)
Q)Calculate Sum and Percentage of Marks

a) Calculates the total marks and percentage based on the marks entered. It divides the total marks by 5 to get the average and then calculates the percentage, finally printing both.

# Calculate sum of marks
total_marks = sum(marks)

# Calculate percentage
percentage = (total_marks / (5 * 100)) * 100

# Display the sum and percentage
print(f"Total marks obtained: {total_marks}")
print(f"Percentage: {percentage}%")
Q)Find Grade Based on Percentage Using if-elif Statements

a)Determines the grade based on the calculated percentage using if-elif statements. It checks the percentage against predefined ranges and assigns a grade accordingly, then displays the grade.

# Determine grade based on percentage using if-elif statements
if percentage > 85:
    grade = "A"
elif percentage >= 75:
    grade = "B"
elif percentage >= 50:
    grade = "C"
elif percentage >= 30:
    grade = "D"
else:
    grade = "Reappear"

# Display the grade
print(f"Grade: {grade}")
1.13. Write a program for VIBGYOR Spectrum based on their Wavelength using. Wavelength Range:

Color Wavelength Range (nanometers)
Violet 400 - 440

Indigo 440 - 460

Blue 460 - 500

Green 500 - 570

Yellow 570 - 590

Orange 590 - 620

Red 620 - 720

wavelength = float(input("Enter the wavelength in nanometers: "))

# Determine and print the corresponding color
if 400 <= wavelength < 440:
    print("The color is Violet")
elif 440 <= wavelength < 460:
    print("The color is Indigo")
elif 460 <= wavelength < 500:
    print("The color is Blue")
elif 500 <= wavelength < 570:
    print("The color is Green")
elif 570 <= wavelength < 590:
    print("The color is Yellow")
elif 590 <= wavelength < 620:
    print("The color is Orange")
elif 620 <= wavelength <= 720:
    print("The color is Red")
else:
    print("Wavelength is outside the visible spectrum")
1.14.Consider the gravitational interactions between the Earth, Moon, and Sun in Our solar system.

Given: mass _earth = 5.972e24 # Mass of Earth in kilograms

mass _moon = 7.34767309e22 # Mass of Moon in kilograms

mass_sun=1.989e30 # Mass of Sun in kilograms

distance_earth _sun 1.496e11 # Average distance between Earth and Sun in meters

distance_ moon_earth 3.844e8 # Average distance between Moon and Earth in meters Tasks:

• Calculate the gravitational force between the Earth and the Sun.

# Constants
G = 6.67430e-11  # Gravitational constant in m^3 kg^-1 s^-2

# Given masses and distance
mass_earth = 5.972e24  # Mass of Earth in kilograms
mass_sun = 1.989e30  # Mass of Sun in kilograms
distance_earth_sun = 1.496e11  # Average distance between Earth and Sun in meters

# Calculate gravitational force between Earth and Sun
force_earth_sun = G * (mass_earth * mass_sun) / (distance_earth_sun ** 2)

print(f"The gravitational force between Earth and Sun is {force_earth_sun:.2e} Newtons")
Calculate the Gravitational Force between Moon and Earth

# Given mass and distance
mass_moon = 7.34767309e22  # Mass of Moon in kilograms
distance_moon_earth = 3.844e8  # Average distance between Moon and Earth in meters

# Calculate gravitational force between Moon and Earth
force_moon_earth = G * (mass_moon * mass_earth) / (distance_moon_earth ** 2)

print(f"The gravitational force between Moon and Earth is {force_moon_earth:.2e} Newtons")
Compare the Gravitational Forces

# Compare the gravitational forces
if force_earth_sun > force_moon_earth:
    stronger_force = "Earth and Sun"
else:
    stronger_force = "Moon and Earth"

print(f"The stronger gravitational force is between {stronger_force}")
• Explain which celestial body (Earth or Moon) is more attracted to the other based on the comparison.

1.The gravitational force between the Earth and the Sun is much stronger than the gravitational force between the Moon and the Earth.

2.This means that Earth is more attracted to the Sun than to the Moon.

3.Despite the Moon being much closer to Earth than the Sun, the Sun's significantly larger mass results in a much stronger gravitational pull on Earth compared to the Moon.

Q2. Design and implement a python program for managing student information using object—oriented principles. Create a class called -student- with encapsulated attributes for name, age, and roll number. Implement getter and setter methods for these attributes. Additionally, provide methods to display student information and update student details.

Tasks:

• Define the •Student' class with encapsulated attributes. class Student:

    def __init__(self, name, age, roll_number):
        self.__name = name
        self.__age = age
        self.__roll_number = roll_number

    # Getter methods
    def get_name(self):
        return self.__name

    def get_age(self):
        return self.__age

    def get_roll_number(self):
        return self.__roll_number

    # Setter methods
    def set_name(self, name):
        self.__name = name

    def set_age(self, age):
        self.__age = age

    def set_roll_number(self, roll_number):
        self.__roll_number = roll_number
Implement Getter and Setter Methods for the Attributes

    # Method to display student information
    def display_info(self):
        print(f"Name: {self.__name}, Age: {self.__age}, Roll Number: {self.__roll_number}")

    # Method to update student details
    def update_details(self, name=None, age=None, roll_number=None):
        if name:
            self.__name = name
        if age:
            self.__age = age
        if roll_number:
            self.__roll_number = roll_number
Create Instances Of the Student Class and Test the Implemented Functionality

# Create instances of Student class
student1 = Student("John Doe", 18, "S123")
student2 = Student("Jane Smith", 20, "S456")

# Display initial information
student1.display_info()
student2.display_info()

# Update student1's details
student1.set_age(19)
student1.update_details(name="Johnathan Doe")

# Display updated information
student1.display_info()
Q3.Develop a python program for managing library resources efficiently. Design a class named -LibraryB00kwith attributes like book name, author, and availability Status. Implement methods for borrowing and returning books while ensuring proper encapsulation Of attributes.

Tasks:

• Create the -LibraryBook' class with encapsulated attributes.

class LibraryBook:
    def __init__(self, book_name, author, availability=True):
        self.__book_name = book_name
        self.__author = author
        self.__availability = availability
Implement Methods for Borrowing and Returning Books

    def borrow_book(self):
        if self.__availability:
            self.__availability = False
            print(f"Borrowed: {self.__book_name}")
        else:
            print(f"Sorry, {self.__book_name} is not available.")

    def return_book(self):
        if not self.__availability:
            self.__availability = True
            print(f"Returned: {self.__book_name}")
        else:
            print(f"{self.__book_name} was not borrowed.")
Ensure Proper Encapsulation to Protect Book Details

    def get_details(self):
        return f"Book: {self__book_name}, Author: {self.__author}, Available: {self.__availability}"
Test the Borrowing and Returning Functionality with Sample Data

book1 = LibraryBook("Python Programming", "John Doe")
book2 = LibraryBook("Data Structures", "Jane Smith", False)

# Test borrowing and returning
print(book1.get_details())
book1.borrow_book()
print(book1.get_details())
book1.return_book()
print(book1.get_details())

print(book2.get_details())
book2.borrow_book()
book2.return_book()
Q4.Create a simple banking System using Object-oriented concepts in python. Design classes representing different types Of bank accounts such as savings and checking. Implement methods for deposit, withdraw, and balance inquiry. Utilize inheritance to manage different account types efficiently.

Tasks:

• 1. Define base class(es) for bank accounts with common attributes and methods.

class BankAccount:
    def __init__(self, account_holder, balance=0):
        self.account_holder = account_holder
        self.balance = balance

    def deposit(self, amount):
        self.balance += amount
        print(f"Deposited {amount}. New balance: {self.balance}")

    def withdraw(self, amount):
        if amount > self.balance:
            print("Insufficient funds.")
        else:
            self.balance -= amount
            print(f"Withdrew {amount}. New balance: {self.balance}")

    def get_balance(self):
        return self.balance
Implement Subclasses for Specific Account Types
class SavingsAccount(BankAccount):
 def __init__(self, account_holder, balance=0):
     super().__init__(account_holder, balance)
class CheckingAccount(BankAccount):
 def __init__(self, account_holder, balance=0):
     super().__init__(account_holder, balance)
Provide Methods for Deposit, Withdraw, and Balance Inquiry in Each Subclass
a3)Methods are inherited from the base class, so no need to redefine them.

Test the Banking System by Creating Instances of Different Account Types and Performing Transactions
savings = SavingsAccount("Alice", 1000)
checking = CheckingAccount("Bob", 500)

# Test deposit, withdraw, and balance inquiry
savings.deposit(500)
savings.withdraw(200)
print(f"Savings Account Balance: {savings.get_balance()}")

checking.deposit(300)
checking.withdraw(800)
print(f"Checking Account Balance: {checking.get_balance()}")
Q5)Write a python program that models different animals and their sounds. Design a base class called •Animal* with a method Create subclasses like 'Dog' and 'Cat' that override the method to produce appropriate sounds.

Tasks:

•1. Define the Animal Class with a Method make_sound

class Animal:
    def make_sound(self):
        pass
Create Subclasses Dog and Cat that Override the make_sound Method

class Dog(Animal):
 def make_sound(self):
     return "Woof!"
class Cat(Animal):
 def make_sound(self):
     return "Meow!"
Implement the Sound Generation Logic for Each Subclass

A)Sound logic is implemented in the overridden make_sound methods of the subclasses.

Test the Program by Creating Instances of Dog and Cat and Calling the make_sound Method
# Create instances of Dog and Cat
dog = Dog()
cat = Cat()
# Call the make_sound method
print(dog.make_sound())  # Outputs: Woof!
print(cat.make_sound())  # Outputs: Meow!
Q6.Write a code for Restaurant Management System Using OOPS:

• Create a Menultem class that has attributes such as name, description, price, and category.

class MenuItem:
    def __init__(self, name, description, price, category):
        self.__id = id(self)
        self.name = name
        self.description = description
        self.price = price
        self.category = category
    def get_id(self):
        return self.__id
Implement Methods to Add, Update, and Remove Menu Items

class Menu:
    def __init__(self):
        self.items = []

    def add_item(self, item):
        self.items.append(item)

    def update_item(self, item_id, name=None, description=None, price=None, category=None):
        for item in self.items:
            if item.get_id() == item_id:
                if name: item.name = name
                if description: item.description = description
                if price: item.price = price
                if category: item.category = category
                break

    def remove_item(self, item_id):
        self.items = [item for item in self.items if item.get_id() != item_id]
Q)Use Encapsulation to Hide the Menu Item's Unique ID

A)The unique ID is hidden within the MenuItem class and accessed via the get_id method.

Q)Inherit from the MenuItem Class to Create FoodItem and BeverageItem Classes

class FoodItem(MenuItem):
    def __init__(self, name, description, price, category, cuisine_type):
        super().__init__(name, description, price, category)
        self.cuisine_type = cuisine_type

class BeverageItem(MenuItem):
    def __init__(self, name, description, price, category, size):
        super().__init__(name, description, price, category)
        self.size = size


# test and implimentations
# Create Menu
menu = Menu()

# Add Items
food = FoodItem("Burger", "Cheeseburger", 5.99, "Food", "American")
beverage = BeverageItem("Coke", "Coca-Cola", 1.99, "Beverage", "500ml")
menu.add_item(food)
menu.add_item(beverage)

# Update Item
menu.update_item(food.get_id(), price=6.99)

# Remove Item
menu.remove_item(beverage.get_id())

# Display Menu
for item in menu.items:
    print(f"{item.name}: ${item.price}")
7.Write a code for Hotel Management System using OOPS :

• Create a Room class that has attributes such as room number, room type, rate, and availability (private).

class Room:
    def __init__(self, room_number, room_type, rate):
        self.__id = id(self)
        self.room_number = room_number
        self.room_type = room_type
        self.rate = rate
        self.__availability = True

    def get_id(self):
        return self.__id

    def is_available(self):
        return self.__availability

    def book_room(self):
        if self.__availability:
            self.__availability = False
            return True
        return False

    def check_in(self):
        if not self.__availability:
            self.__availability = True
            return True
        return False

    def check_out(self):
        self.__availability = True
• Inherit from the Room class to create a SuiteRoom class and a StandardRoom class, each with their own specific attributes and methods.

class SuiteRoom(Room):
    def __init__(self, room_number, rate, amenities):
        super().__init__(room_number, "Suite", rate)
        self.amenities = amenities

class StandardRoom(Room):
    def __init__(self, room_number, rate):
        super().__init__(room_number, "Standard", rate)
• Implement methods to book a room, check in a guest, and check out a guest

a)Methods are already implemented in the Room class: book_room, check_in, and check_out

8.Write a code for Fitness Club Management System using OOPS:

• Create a Member class that has attributes such as name, age, membership type, and membership status (private).

class Member:
    def __init__(self, name, age, membership_type):
        self.__id = id(self)
        self.name = name
        self.age = age
        self.membership_type = membership_type
        self.__status = "Active"

    def get_id(self):
        return self.__id

    def get_status(self):
        return self.__status

    def register(self):
        self.__status = "Active"

    def renew_membership(self):
        self.__status = "Renewed"

    def cancel_membership(self):
        self.__status = "Cancelled"
Inherit from the Member Class to Create FamilyMember and IndividualMember Classes

class FamilyMember(Member):
    def __init__(self, name, age, membership_type, family_size):
        super().__init__(name, age, membership_type)
        self.family_size = family_size

class IndividualMember(Member):
    def __init__(self, name, age, membership_type):
        super().__init__(name, age, membership_type)
q)Implement Methods to Register, Renew, and Cancel Membership

a)Methods register, renew_membership, and cancel_membership are already implemented in the Member class

# Test the Implementation
# Create Members
family_member = FamilyMember("John Doe", 40, "Family", 4)
individual_member = IndividualMember("Jane Smith", 30, "Individual")

# Register Members
family_member.register()
individual_member.register()

# Renew Membership
family_member.renew_membership()

# Cancel Membership
individual_member.cancel_membership()

# Check Membership Status
print(family_member.get_status())  # Renewed
print(individual_member.get_status())  # Cancelled
Q9.Write a code for Event Management System using OOPS:

• Create an Event class that has attributes such as name, date, time, location, and list of attendees (private).

class Event:
    def __init__(self, name, date, time, location):
        self.__id = id(self)
        self.name = name
        self.date = date
        self.time = time
        self.location = location
        self.__attendees = []

    def get_id(self):
        return self.__id

    def add_attendee(self, attendee):
        self.__attendees.append(attendee)

    def remove_attendee(self, attendee):
        self.__attendees.remove(attendee)

    def get_total_attendees(self):
        return len(self.__attendees)
Inherit from the Event Class to Create PrivateEvent and PublicEvent Classes

class PrivateEvent(Event):
    def __init__(self, name, date, time, location, invite_only):
        super().__init__(name, date, time, location)
        self.invite_only = invite_only

class PublicEvent(Event):
    def __init__(self, name, date, time, location, max_capacity):
        super().__init__(name, date, time, location)
        self.max_capacity = max_capacity
Q)Implement Methods to Create, Add/Remove Attendees, and Get Total Number of Attendees

A)Methods add_attendee, remove_attendee, and get_total_attendees are already implemented in the Event class.

# Test and implementation

# Create Events
private_event = PrivateEvent("Birthday Party", "2024-08-20", "18:00", "John's House", True)
public_event = PublicEvent("Concert", "2024-09-15", "20:00", "Central Park", 500)

# Add Attendees
private_event.add_attendee("Alice")
private_event.add_attendee("Bob")
public_event.add_attendee("Charlie")

# Remove Attendee
private_event.remove_attendee("Bob")

# Get Total Attendees
print(private_event.get_total_attendees())  # 1
print(public_event.get_total_attendees())  # 1
Q10.Write a code for Airline Reservation System using OOPS:

• Create a Flight class that has attributes such as flight number, departure and arrival airports, departure and arrival times, and available seats (private).

class Flight:
    def __init__(self, flight_number, departure_airport, arrival_airport, departure_time, arrival_time, total_seats):
        self.__id = id(self)
        self.flight_number = flight_number
        self.departure_airport = departure_airport
        self.arrival_airport = arrival_airport
        self.departure_time = departure_time
        self.arrival_time = arrival_time
        self.__available_seats = total_seats

    def get_id(self):
        return self.__id

    def book_seat(self):
        if self.__available_seats > 0:
            self.__available_seats -= 1
            return True
        else:
            return False

    def cancel_reservation(self):
        if self.__available_seats < total_seats:
            self.__available_seats += 1
            return True
        else:
            return False

    def get_available_seats(self):
        return self.__available_seats
Inherit from the Flight Class to Create DomesticFlight and InternationalFlight Classes

class DomesticFlight(Flight):
    def __init__(self, flight_number, departure_airport, arrival_airport, departure_time, arrival_time, total_seats, baggage_allowance):
        super().__init__(flight_number, departure_airport, arrival_airport, departure_time, arrival_time, total_seats)
        self.baggage_allowance = baggage_allowance

class InternationalFlight(Flight):
    def __init__(self, flight_number, departure_airport, arrival_airport, departure_time, arrival_time, total_seats, meal_service):
        super().__init__(flight_number, departure_airport, arrival_airport, departure_time, arrival_time, total_seats)
        self.meal_service = meal_service
q)Implement Methods to Book a Seat, Cancel a Reservation, and Get Remaining Available Seats

a)Methods book_seat, cancel_reservation, and get_available_seats are already implemented in the Flight class.

# test and implementation
# Create Flights
domestic_flight = DomesticFlight("DF101", "JFK", "LAX", "10:00", "14:00", 150, "20 kg")
international_flight = InternationalFlight("IF202", "LHR", "JFK", "08:00", "16:00", 200, "Standard Meal")

# Book Seats
print(domestic_flight.book_seat())  # True (Seat booked)
print(international_flight.book_seat())  # True (Seat booked)

# Cancel Reservation
print(domestic_flight.cancel_reservation())  # True (Reservation cancelled)

# Get Available Seats
print(domestic_flight.get_available_seats())  # 149
print(international_flight.get_available_seats())  # 199
Q)11. Define a python module named constants.py containing constants like pi and the speed Of light.

# constants.py
PI = 3.14159
SPEED_OF_LIGHT = 299792458  # meters per second
q12. Write a python module named calculator.py containing functions for addition, subtraction, multiplication, and division.

# calculator.py
def add(a, b):
    return a + b

def subtract(a, b):
    return a - b

def multiply(a, b):
    return a * b

def divide(a, b):
    if b != 0:
        return a / b
    else:
        return "Error: Division by zero"
q13. Implement a Python package structure for a project named ecommerce, containing modules for product management and order processing.

ecommerce/
    __init__.py
    product_management.py
    order_processing.py
q14. Implement a python module named string_utils.py containing functions for string manipulation, such as reversing and capitalizing strings.

# string_utils.py
def reverse_string(s):
    return s[::-1]

def capitalize_string(s):
    return s.capitalize()
q15) Write a Python module named file_operations.py with functions for reading, writing, and appending data to a file.

# file_operations.py
def read_file(filename):
    with open(filename, 'r') as file:
        return file.read()

def write_to_file(filename, data):
    with open(filename, 'w') as file:
        file.write(data)

def append_to_file(filename, data):
    with open(filename, 'a') as file:
        file.write(data + '\n')
q16. Write a python program to create a text file named "employees.txt" and write the details Of employees, including their name, age, and salary, into the file.

# Creating employees.txt
with open("employees.txt", 'w') as file:
    file.write("Name: John Doe\nAge: 30\nSalary: $50000\n")
    file.write("Name: Jane Smith\nAge: 25\nSalary: $45000\n")
q17. Develop a python script that opens an existing text file named "inventory.txt" in read mode and displays the contents Of the file line by line.

# Reading inventory.txt
with open("inventory.txt", 'r') as file:
    for line in file:
        print(line.strip())
q18. Create a python script that reads a text file named "expenses.txt" and calculates the total amount spent on various expenses listed in the file.

# Calculating total expenses from expenses.txt
total_expenses = 0
with open("expenses.txt", 'r') as file:
    for line in file:
        try:
            expense = float(line.strip().split()[1])  # Assuming format is 'Expense: amount'
            total_expenses += expense
        except ValueError:
            pass  # Ignore lines that don't match expected format

print(f"Total expenses: ${total_expenses}")
q19. Create a python program that reads a text file named "paragraph.txt" and counts the occurrences Of each word in the paragraph, displaying the results in alphabetical order.

# Counting word occurrences in paragraph.txt
from collections import defaultdict

word_counts = defaultdict(int)
with open("paragraph.txt", 'r') as file:
    for line in file:
        words = line.strip().split()
        for word in words:
            word_counts[word.lower()] += 1

# Display results in alphabetical order
for word in sorted(word_counts):
    print(f"{word}: {word_counts[word]}")
q20. What do you mean by Measure of Central Tendency and Measures of Dispersion. How it can be calculated. a)Measure of Central Tendency:

Mean: Sum of values divided by the number of values. Median: Middle value when values are sorted. Mode: Most frequently occurring value. Measures of Dispersion:

Range: Difference between the maximum and minimum values. Variance: Average of squared differences from the mean. Standard Deviation: Square root of variance.

q21. What do you mean by skewness. Explain its types and use graph to show.

a)Skewness:

Measures asymmetry in data distribution. Positive skew: Tail on the right side of the distribution.

Negative skew: Tail on the left side of the distribution.

Graphically, positive skew means the mean > median > mode, and negative skew means the mode > median > mean.

q22. Explain PROBABILITY MASS FUNCTION (PMF) and PROBABILITY DENSITY FUNCTION (PDF), and what is the difference between them?

a)PMF: Probability distribution of discrete random variables.

PDF: Probability distribution of continuous random variables.

PMF gives probabilities for discrete outcomes, while PDF gives probabilities for continuous outcomes. PDF is also the derivative of the cumulative distribution function (CDF).

q23. What is correlation. Explain its types in detail and what are the methods of determining correlation.

Correlation:

Measures strength and direction of relationship between two variables.

Types: Pearson correlation (linear relationship), Spearman correlation (monotonic relationship), Kendall correlation (ordinal variables).

Methods: Calculate correlation coefficient (ranges from -1 to 1), visualize with scatter plots, and test significance with hypothesis tests like t-test or p-value.

Calculate coefficient of correlation between the marks obtained by 10 students in Accountancy and statistics:

student: 1 2 3 4 5 6 7 8 9 10

Accountancy 45 70 65 30 90 40 50 75 85 60

statistics 35 90 70 40 95 40 60 80 80 50

a) the coefficient of correlation (Pearson's correlation coefficient) between the marks obtained in Accountancy and Statistics for 10 students

import numpy as np

# Marks data
accountancy_marks = np.array([45, 70, 65, 30, 90, 40, 50, 75, 85, 60])
statistics_marks = np.array([35, 90, 70, 40, 95, 40, 60, 80, 80, 50])

# Calculate Pearson correlation coefficient
correlation_coefficient = np.corrcoef(accountancy_marks, statistics_marks)[0, 1]

print(f"Pearson's correlation coefficient: {correlation_coefficient}")
q25. Discuss the 4 differences between correlation and regression.

a)Purpose: Correlation measures the strength and direction of the relationship between two variables. Regression predicts the value of one variable based on another.

Nature: Correlation is symmetrical; it measures the association between variables without implying causation. Regression is directional; it establishes a predictive model.

Variables: Correlation involves two variables treated equally. Regression distinguishes between independent (predictor) and dependent (outcome) variables.

Output: Correlation produces a correlation coefficient. Regression gives an equation to predict values.

Q26. Find the most likely price at Delhi corresponding to the price of Rs. 70 at Agra from the following data: Coefficient of correlation between the prices of the two places +0.8.

A)Given a correlation coefficient of +0.8 between Agra and Delhi prices, to find the price at Delhi corresponding to Rs. 70 at Agra, use regression or the correlation coefficient directly. If Rs. 70 at Agra corresponds to a high positive correlation, a likely price at Delhi could be higher than Rs. 70.

q27) In a partially destroyed laboratory record of an analysis of correlation data, the following results only are legible: Variance of x = 9, Regression equations are: (i) 8x-10y = —66; (ii) 40x -18y = 214. What are (a) the mean values of x and y, (b) the coefficient of correlation between x and y, (c) the c of y.

import numpy as np
from sympy import symbols, Eq, solve

# (a) Mean values of x and y

# Given regression equations
# 8x - 10y = -66
# 40x - 18y = 214

# Define symbols
x, y = symbols('x y')

# Define the equations
eq1 = Eq(8*x - 10*y, -66)
eq2 = Eq(40*x - 18*y, 214)

# Solve the equations simultaneously
solution = solve((eq1, eq2), (x, y))

mean_x = solution[x]
mean_y = solution[y]

print(f"Mean of x: {mean_x}")
print(f"Mean of y: {mean_y}")

# (b) Coefficient of correlation between x and y

# Given regression coefficients
b_yx = 8 / 10
b_xy = 18 / 40

# Correlation coefficient r
r = np.sqrt(b_yx * b_xy)

print(f"Correlation coefficient: {r}")

# (c) Constant of y

# Using mean values and regression coefficient
a = mean_y - b_yx * mean_x

print(f"Constant of y: {a}")
q28. What is Normal Distribution? What are the four Assumptions of Normal Distribution? Explain in detail.

a)Normal distribution is a bell-shaped curve that's symmetric around the mean. It's often called the Gaussian distribution. The mean, median, and mode are all equal and located at the center of the distribution.

Four Assumptions of Normal Distribution:

Symmetry: The distribution is symmetric around the mean.

Equal Mean, Median, and Mode: These measures of central tendency are all the same.

Asymptotic: The tails of the distribution approach the horizontal axis but never touch it.

Defined by Mean and Standard Deviation: The distribution's shape is determined by these two parameters.

Q29.Write all the characteristics or properties of the Normal Distribution Curve.

A)Characteristics of the Normal Distribution Curve

Symmetry: The curve is symmetric around the mean.

Mean, Median, and Mode: All are equal and located at the center.

Bell-shaped: The curve has a single peak at the mean.

Asymptotic: The tails approach the horizontal axis but never touch it.

Empirical Rule: About 68% of the data falls within one standard deviation of the mean, 95% within two, and 99.7% within three.

Q30)Which of the following options are correct about Normal Distribution Curve

(a) Within a range 0.6745 of o on both sides the middle 50% of the observations occur i,e. mean *0.67450 covers 50% area 25% on each side.

a): False. The correct range for covering 50% of the area is within ±0.6745σ, not μ×0.6745.

(b) Mean ±IS.D. (i,e.p ± 10) covers 68.268% area, 34.134 % area lies on either side of the mean.

b): True. μ±1σ covers approximately 68.268% of the area under the normal distribution curve.

(c) Mean ±2S.D. (i,e. ± 20) covers 95.45% area, 47.725% area lies on either side of the mean. (c): True.μ±2σ covers approximately 95.45% of the area under the normal distribution curve

(d) Mean S.D. (i,e. p ±30) covers 99.73% area, 49.856% area lies on the either side of the mean.

d) Mean S.D. (i,e. p ±30) covers 99.73% area, 49.856% area lies on the either side of the mean.

(e) Only 0.27% area is outside the range p *3.0

e): True. Only 0.27% of the area is outside the range μ±3σ.

Q31) The mean of a distribution is 60 with a standard deviation of 10. Assuming that the distribution is normal, what percentage of items be (i) between 60 and 72, (ii) between 50 and 60, (iii) beyond 72 and (iv) between 70 and 80? a)

Given: Mean = 60, Standard Deviation = 10.

(i) Between 60 and 72:
   - Use the Z-score formula: \( Z = \frac{X - \mu}{\sigma} \)
   - Calculate Z-scores: \( Z_{60} = \frac{60 - 60}{10} = 0 \),
     \( Z_{72} = \frac{72 - 60}{10} = 1.2 \).
   - Look up Z-table or use Python's scipy.stats.norm.cdf() function.
   - Approximate percentage: Around 21.22%.

(ii) Between 50 and 60:
   - Z-scores: \( Z_{50} = \frac{50 - 60}{10} = -1 \),
     \( Z_{60} = 0 \).
   - Approximate percentage: Around 34.13%.

(iii) Beyond 72 (greater than 72):
   - Z-score for 72: \( Z_{72} = 1.2 \).
   - Use complement rule: \( 1 - \text{cdf}(Z_{72}) \).
   - Approximate percentage: Around 11.35%.

(iv) Between 70 and 80:
   - Z-scores: \( Z_{70} = \frac{70 - 60}{10} = 1 \),
     \( Z_{80} = \frac{80 - 60}{10} = 2 \).
   - Approximate percentage: Around 31.73%.
.
q32. 15000 students sat for an examination. The mean marks was 49 and the distribution of marks had a standard deviation of 6. Assuming that the marks were normally distributed what proportion of students scored (a) more than 55 marks, (b) more than 70 marks

Given: Mean = 49, Standard Deviation = 6, Total students = 15000.

(a) Proportion of students scoring more than 55 marks:
   - Z-score for 55: \( Z_{55} = \frac{55 - 49}{6} = 1 \).
   - Use complement rule: \( 1 - \text{cdf}(Z_{55}) \).
   - Approximate percentage: Around 15.87%.

(b) Proportion of students scoring more than 70 marks:
   - Z-score for 70: \( Z_{70} = \frac{70 - 49}{6} = 3.5 \).
   - Use complement rule: \( 1 - \text{cdf}(Z_{70}) \).
   - Approximate percentage: Around 0.03%.
If the height of 500 students are normally distributed with mean 65 inch and standard deviation 5 inch. How many students have height : a) greater than 70 inch. b) between 60 and 70 inch.
Given: Mean = 65 inches, Standard Deviation = 5 inches, Total students = 500.

(a) Number of students with height greater than 70 inches:
   - Z-score for 70 inches: \( Z_{70} = \frac{70 - 65}{5} = 1 \).
   - Use the complement rule: \( 1 - \text{cdf}(Z_{70}) \).
   - Approximate percentage: Around 15.87%.
   - Number of students: \( \text{Total students} \times \text{Percentage} = 500 \times 0.1587 = 79.35 \).

   Since you can't have a fraction of a student, round to the nearest whole number:
   - Number of students greater than 70 inches: Approximately 79.

(b) Number of students with height between 60 and 70 inches:
   - Z-score for 60 inches: \( Z_{60} = \frac{60 - 65}{5} = -1 \).
   - Z-score for 70 inches: \( Z_{70} = \frac{70 - 65}{5} = 1 \).
   - Calculate the area between these two Z-scores using the difference of cdf values:
     \( \text{cdf}(Z_{70}) - \text{cdf}(Z_{60}) \).
   - Approximate percentage: Around 68.27%.
   - Number of students: \( 500 \times 0.6827 = 341.35 \).

   Round to the nearest whole number:
   - Number of students between 60 and 70 inches: Approximately 341.
35.A random sample of size 25 from a population gives the sample standard derivation to be 9.0. Test the hypothesis that the population standard derivation is 10.5. Hint(use chi- square distribution).

statistical hypothesis a)Statistical hypothesis is a statement o r assumption about the population parameters, tested using statistical methods to determine if there is enough evidence to reject or fail to reject the null hypothesis (H₀).

Errors in Hypothesis Testing: Type I Error: Occurs when we reject the null hypothesis (H₀) when it is actually true. It's a false positive.

Type II Error: Occurs when we fail to reject the null hypothesis (H₀) when it is actually false. It's a false negative.

Sample Explanation: Sample: A subset of individuals or objects selected from a larger population to represent it in a study or experiment.

Large Samples vs. Small Samples:

Large Samples: Typically have more than 30 observations. They tend to provide more reliable estimates of population parameters and are less affected by random fluctuations.

Small Samples: Usually have fewer than 30 observations. They can still provide insights but are more susceptible to random variability, making generalizations to the population more challenging.

Q37)100 students of a PW 101 obtained the following grades in Data Science paper : Grade : [A,B, C, D, E]

Total Frequency : [15,17, 30, 22, 16, 100]

Using the X(sigma)2 test , examine the hypothesis that the distribution of grades is uniform.

a)x`Given Data:

Grades: A, B, C, D, E

Frequencies: 15, 17, 30, 22, 16

Total students: 100

Calculate Expected Frequencies:

If the distribution were uniform, each grade would have an expected frequency of 100/5=20.

Set up Hypotheses:

Null Hypothesis (H₀): The distribution of grades is uniform.

Alternative Hypothesis (H₁): The distribution of grades is not uniform.

Compute Chi-square Statistic:

𝜒2=∑(𝑂𝑖−𝐸𝑖)2/Ei, where Oi is the observed frequency and Ei is the expected frequency for each grade.

Degrees of Freedom:

Degrees of freedom (df) = Number of categories - 1 = 5 - 1 = 4.

Compare with Critical Value: Use a Chi-square table or function (like scipy.stats.chi2) to find the critical value for χ2 with 4 degrees of freedom at a chosen significance level (e.g., 0.05).

Q36) Not Available in assignment PDF

Double-click (or enter) to edit

q38.Anova Test: TO study the performance Of three detergents and three different water temperatures the following whiteness readings were obtained with specially designed equipment.

Water temp | Detergents A | Detergents B | Detergents C

Cold Water | 57 | 55 | 67

Worm Water | 49 | 52 | 68

Hot Water | 54 | 46 | 58

Data:

Cold Water: [57, 55, 67]

Warm Water: [49, 52, 68]

Hot Water: [54, 46, 58]

Hypotheses:

H₀: No difference in mean whiteness among detergents and water temperatures. H₁: At least one mean whiteness is different

import pandas as pd
import scipy.stats as stats

# Data
data = {
    'Detergent A': [57, 49, 54],
    'Detergent B': [55, 52, 46],
    'Detergent C': [67, 68, 58]
}

df = pd.DataFrame(data, index=['Cold Water', 'Warm Water', 'Hot Water'])

# Reshape data for ANOVA
df_melt = pd.melt(df.reset_index(), id_vars=['index'], value_vars=['Detergent A', 'Detergent B', 'Detergent C'])
df_melt.columns = ['Water_Temperature', 'Detergent', 'Whiteness']

# ANOVA test
anova_result = stats.f_oneway(
    df_melt[df_melt['Detergent'] == 'Detergent A']['Whiteness'],
    df_melt[df_melt['Detergent'] == 'Detergent B']['Whiteness'],
    df_melt[df_melt['Detergent'] == 'Detergent C']['Whiteness']
)

anova_result
Q39.How would you create a basic Flask route that displays "Hello, World!" on the homepage?

# !pip install Flask
# Import Flask
from flask import Flask

# Create Flask app
app = Flask(__name__)

# Define route for homepage
@app.route('/')
def home():
    return "Hello, World!"

# Run the app
if __name__ == '__main__':
    app.run()
q40.Explain how to set up a Flask application to handle form submissions using POST requests.

from flask import Flask, request, render_template_string

app = Flask(__name__)

# Define the form template
form_template = '''
<!doctype html>
<html>
<body>
    <form method="POST" action="/">
        <input type="text" name="name">
        <input type="submit">
    </form>
</body>
</html>
'''

# Define the route to display the form
@app.route('/', methods=['GET', 'POST'])
def form():
    if request.method == 'POST':
        name = request.form['name']
        return f"Hello, {name}!"
    return render_template_string(form_template)

# Run the app
if __name__ == '__main__':
    app.run()
q41.Write a Flask route that accepts a parameter in the URL and displays it on the page.

from flask import Flask

app = Flask(__name__)

# Define the route with a parameter
@app.route('/hello/<name>')
def hello(name):
    return f"Hello, {name}!"

# Run the app
if __name__ == '__main__':
    app.run()
Q42.How can you implement user authentication in a Flask application?

!pip install Flask Flask-Login
from flask import Flask, render_template_string, redirect, url_for, request
from flask_login import LoginManager, UserMixin, login_user, login_required, logout_user, current_user

app = Flask(__name__)
app.secret_key = 'secretkey'
login_manager = LoginManager()
login_manager.init_app(app)

# User class
class User(UserMixin):
    def __init__(self, id):
        self.id = id

# User loader
@login_manager.user_loader
def load_user(user_id):
    return User(user_id)

# Login route
@app.route('/login', methods=['GET', 'POST'])
def login():
    if request.method == 'POST':
        user = User(request.form['username'])
        login_user(user)
        return redirect(url_for('protected'))
    return '''
    <form method="POST" action="/login">
        <input type="text" name="username">
        <input type="submit">
    </form>
    '''

# Protected route
@app.route('/protected')
@login_required
def protected():
    return f'Logged in as: {current_user.id}'

# Logout route
@app.route('/logout')
@login_required
def logout():
    logout_user()
    return 'Logged out!'

# Run the app
if __name__ == '__main__':
    app.run()
Q43.Describe the process of connecting a Flask app to a SQLite database using SQLAIchemy.

!pip install Flask-SQLAlchemy
from flask import Flask
from flask_sqlalchemy import SQLAlchemy

app = Flask(__name__)
app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///test.db'
db = SQLAlchemy(app)

# Define a model
class User(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    username = db.Column(db.String(80), unique=True, nullable=False)

# Create the database and tables
with app.app_context():
    db.create_all()

# Run the app
if __name__ == '__main__':
    app.run()
q44.How would you create a RESTful API endpoint in Flask that returns JSON data?

!pip install Flask
from flask import Flask, jsonify

app = Flask(__name__)

@app.route("/api/data", methods=['GET'])
def get_data():
    data = {'key': 'value', 'number': 42}
    return jsonify(data)

# Run the app
if __name__ == '__main__':
    app.run()
Q45.Explain how to use Flask—WTF to create and validate forms in a Flask application.

!pip install Flask-WTF
from flask import Flask, render_template_string, request
from flask_wtf import FlaskForm
from wtforms import StringField, SubmitField
from wtforms.validators import DataRequired

app = Flask(__name__)
app.secret_key = 'secretkey'

class MyForm(FlaskForm):
    name = StringField('Name', validators=[DataRequired()])
    submit = SubmitField('Submit')

@app.route('/', methods=['GET', 'POST'])
def form():
    form = MyForm()
    if form.validate_on_submit():
        return f"Hello, {form.name.data}!"
    return render_template_string('''
    <form method="POST">
        {{ form.hidden_tag() }}
        {{ form.name.label }} {{ form.name() }}
        {{ form.submit() }}
    </form>
    ''', form=form)

# Run the app
if __name__ == '__main__':
    app.run()
Q46.How can you implement file uploads in a Flask application?

!pip install Flask
from flask import Flask, request, render_template_string

app = Flask(__name__)
app.config['UPLOAD_FOLDER'] = '/path/to/upload'

@app.route('/', methods=['GET', 'POST'])
def upload_file():
    if request.method == 'POST':
        file = request.files['file']
        if file:
            file.save(os.path.join(app.config['UPLOAD_FOLDER'], file.filename))
            return 'File uploaded successfully'
    return '''
    <form method="POST" enctype="multipart/form-data">
        <input type="file" name="file">
        <input type="submit">
    </form>
    '''

# Run the app
if __name__ == '__main__':
    app.run()
Q47.Describe the Steps to create a Flask blueprint and why you might use one.

!pip install Flask
from flask import Flask, Blueprint

# Create a blueprint
my_blueprint = Blueprint('my_blueprint', __name__)

@my_blueprint.route('/hello')
def hello():
    return "Hello from blueprint!"

# Create Flask app
app = Flask(__name__)
app.register_blueprint(my_blueprint, url_prefix='/blueprint')

# Run the app
if __name__ == '__main__':
    app.run()
use a blueprint Organizes code into modular components.

Makes the app easier to manage and scale.

Q48.How would you deploy a Flask application to a production server using Gunicorn and Nginx?

# Install Gunicorn:
pip install gunicorn
# Run Flask app with Gunicorn:
gunicorn -w 4 myapp:app
# Nginx configuration:
# Edit /etc/nginx/sites-available/myapp:
server {
    listen 80;
    server_name your_domain;

    location / {
        proxy_pass http://127.0.0.1:8000;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }
}
# Enable Nginx site:
sudo ln -s /etc/nginx/sites-available/myapp /etc/nginx/sites-enabled
sudo systemctl restart nginx
Q49. Make a fully functional web application using flask, Mangodb. Signup,Signin page.And after successfully login Say hello Geeks message at webpage.

!pip install Flask Flask-PyMongo Flask-Bcrypt Flask-Login
# Flask app with MongoDB:
from flask import Flask, render_template_string, request, redirect, url_for
from flask_pymongo import PyMongo
from flask_bcrypt import Bcrypt
from flask_login import LoginManager, UserMixin, login_user, login_required, logout_user, current_user

app = Flask(__name__)
app.config['MONGO_URI'] = 'mongodb://localhost:27017/mydatabase'
app
50.Machine Learning:

• What is the difference between Series & Dataframes .

-*Series: A one-dimensional labeled array capable of holding any data type.

*DataFrame: A two-dimensional labeled data structure with columns of potentially different types.

• Create a database name Travel_planner in mysql ,and create a table name bookings in that which having attributes (user_id INT, flight_id INT, activity_id DATE) fill with some dummy value -Now you have to read the content of this table using pandas as dataframe.Show the output.

CREATE DATABASE Travel_planner;
USE Travel_planner;
CREATE TABLE bookings (
    user_id INT,
    flight_id INT,
    activity_date DATE
);
INSERT INTO bookings (user_id, flight_id, activity_date) VALUES 
(1, 101, '2023-07-01'),
(2, 102, '2023-07-02'),
(3, 103, '2023-07-03');
!pip install pymysql sqlalchemy pandas

import pandas as pd
from sqlalchemy import create_engine

# Create engine
engine = create_engine('mysql+pymysql://username:password@localhost/Travel_planner')

# Read table into DataFrame
df = pd.read_sql('SELECT * FROM bookings', engine)
print(df)
• Difference between loc and iloc.

- *loc: Access a group of rows and columns by labels or a boolean array.

*iloc: Access a group of rows and columns by integer positions (indices).

• What is the difference between supervised and unsupervised learning?

- *Supervised Learning: The model is trained on labeled data (input-output pairs).

*Unsupervised Learning: The model is trained on unlabeled data and finds hidden patterns or intrinsic structures.

• Explain the bias-variance tradeoff.

-*Bias: Error due to overly simplistic models, missing patterns.

*Variance: Error due to overly complex models, capturing noise.

*Tradeoff: Aim to find a balance; too much bias misses patterns, too much variance overfits.

• What are precision and recall? How are they different from accuracy?

- **Precision: True Positives/ True Positives+False Positives

**Recall: True Positives/True Positive+False Negatives

**Accuracy: True Positives+True Negatives/Total Samples

**Difference: Precision measures correctness of positive predictions; recall measures how well positives are identified.

• What is overfitting and how can it be prevented?

-**Overfitting: Model learns noise, not just patterns.

**Prevention: Use cross-validation, regularization, pruning, simpler models, more data.

• Explain the concept Of cross-validation.

-Concept: Split data into k-folds, train on k-1 folds, validate on remaining fold. Repeat k times, average results.

• What is the difference between a classification and a regression problem?

-*Classification: Predict categorical outcomes (e.g., spam/not spam).

*Regression: Predict continuous outcomes (e.g., house prices).

• Explain the concept Of ensemble learning.

=Concept: Combine multiple models to improve performance (e.g., bagging, boosting).

• What is gradient descent and how does it work?

= *Concept: Optimization algorithm to minimize loss function.

*How it Works: Update model parameters iteratively by moving in the direction of negative gradient.

• Describe the difference between batch gradient descent and stochastic gradient descent.

=*Batch: Uses all training data at once for updates.

*Stochastic: Uses one training sample per update, faster but noisier.

• What is the Curse Of dimensionality in machine learning?

=Concept: High-dimensional spaces make learning and generalizing difficult due to sparse data

• Explain the difference between Ll and L2 regularization.

-*L1 (Lasso): Adds absolute values of coefficients to loss function, can produce sparse models.

*L2 (Ridge): Adds squared values of coefficients to loss function, keeps all coefficients small.

• What is a confusion matrix and how is it used?

=Concept: Table to evaluate performance of classification models. Shows true vs predicted classes

• Define AUC-ROC curve.

=AUC: Area under the ROC curve, measures classifier performance.

ROC Curve: Plots true positive rate vs false positive rate across thresholds.

• Explain the k-nearest neighbors algorithm.

=Concept: Classify a data point based on the majority class of its k nearest neighbors.

How it Works: Calculate the distance between points, find the nearest k neighbors, and assign the majority label.

• Explain the basic concept of a Support Vector Machine (SVM).

*Concept: Find the optimal hyperplane that separates classes in a dataset.

*How it Works: Maximize the margin between the closest points (support vectors) of different classes

• How does the kernel trick work in SVM?

= Use kernel functions (e.g., linear, polynomial, RBF) to implicitly map input features

• What are the different types of kernels used in SVM and when would you use each? - *Linear: Use when data is linearly separable.

*Polynomial: Use when data has polynomial relationships.

*RBF (Gaussian): Use when data has complex boundaries.

• What is the hyperplane in SVM and how is it determined? =-Concept: The decision boundary that separates different classes.

-Determination: Found by maximizing the margin between the closest points of the classes.

• What are the pros and cons of using a Support Vector Machine (SVM)?

= -Pros: Effective in high-dimensional spaces, robust to overfitting with proper regularization.

-Cons: Computationally intensive, less effective on large datasets with noise

• Explain the difference between a hard margin and a soft margin SVM.

= *Hard Margin: No misclassifications allowed, only works with linearly separable data.

*Soft Margin: Allows some misclassifications, uses a regularization parameter to balance margin width and misclassification.

• Describe the process of constructing a decision tree.

=Process: Split data recursively based on feature values to create branches, stop when leaves are pure or other stopping criteria are met.

• Describe the working principle of a decision tree.

=Concept: Use a tree structure to make decisions based on feature values, starting from the root and moving to leaves.

• What is information gain and how is it used in decision trees?

=-Concept: Measure of how well a feature separates the classes.

-Usage: Select features with the highest information gain to split nodes.

• Explain Cini impurity and its role in decision trees.

*Concept: Measure of impurity or disorder in a dataset.

*Role: Used to select features by minimizing impurity in splits.

• What are the advantages and disadvantages of decision trees?

=*Advantages: Easy to understand, interpretable, handles both numerical and categorical data.

*Disadvantages: Prone to overfitting, sensitive to small data changes.

• How do random forests improve upon declsion trees?

= -Improvement: Combine multiple trees to reduce overfitting and improve generalization.

-How it Works: Create multiple trees using bootstrapped subsets of data and aggregate their predictions

• How does a random forest algorithm work? =1.Data Sampling: Random subsets of data created using bootstrapping.

2.Tree Construction: Multiple decision trees built with random feature subsets.

V3.oting: Trees vote on classification or average predictions for regression.

4.Final Prediction: Combines tree outputs for robust predictions.

• What is bootstrapping in the context of random forests?

=-Definition: Sampling technique with replacement to create multiple datasets.

-Purpose: Generates diverse subsets for training individual decision trees in Random Forests.

• Explain the concept of feature importance in random forests.

=Definition: Measures impact of each feature on model predictions.

Calculation: Analyzes how much each feature contributes to reducing prediction error across all trees.

• What are the key hyperparameters of a random forest and how do they affect the model?

=*Number of Trees: Increases model complexity and computational cost.

*Max Features: Controls the number of features considered for splitting.

*Tree Depth: Influences model complexity and overfitting

• Describe the logistic regression model and its assumptions.

=-Model: Linear regression for binary classification.

-Assumptions: Linear relationship between features and log-odds of the outcome.

• How does logistic regression handle binary classification problems?

=Output: Predicts probability of a binary outcome.

Decision: Classifies based on threshold (typically 0.5)

• What is the sigmoid function and how is it used in logistic regression?

=*Definition: S-shaped curve transforming input to a range between 0 and 1.

*Use: Converts logistic regression output into probabilities

• Explain the concept of the cost function in logistic regression.

=-Purpose: Measures model performance by penalizing incorrect predictions.

-Optimization: Minimizes cost using techniques like gradient descent

• How can logistic regression be extended to handle multiclass classification?

=One-vs-Rest: Trains multiple binary classifiers, one for each class.

Softmax Function: Outputs probabilities across multiple classes.

• What is the difference between Ll and L2 regularization in logistic regression?

=*L1 (Lasso): Penalizes absolute weights, promoting sparsity.

*L2 (Ridge): Penalizes squared weights, shrinking coefficients towards zero

• What is XGBoost and how does it differ from other boosting algorithms?

=*Definition: Gradient boosting library for optimized performance.

*Advantages: Handles large datasets, supports regularization, and manages missing values.

• Explain the concept of boosting in the context of ensemble learning.

=-Purpose: Combines weak learners sequentially to improve prediction accuracy.

-Process: Adjusts weights of misclassified instances to prioritize learning from errors.

• How does XGBoost handle missing values?

*Treatment: Automatically handles missing values during training.

*Process: Learns default directions for missing data, reducing prediction bias.

• What are the key hyperparameters in XGBoost and how do they affect model performance?

=1.Number of Trees: Controls the number of boosting rounds.

2.Learning Rate (eta): Scales the contribution of each tree.

3.Tree Depth (max_depth): Limits the depth of each tree.

4.Subsample: Fraction of training data used per tree.

5.Column Subsampling (colsample_bytree): Fraction of features used per tree.

• Describe the process of gradient boosting in XGBoost.

=Initialization: Starts with a simple model (usually a single leaf).

Iterative Improvement: Sequentially adds new models to correct errors made by existing models.

Gradient Descent: Optimizes a loss function by minimizing errors in predictions.

• What are the advantages and disadvantages of using XGBoost? = Advantage

*High Performance: Fast execution speed and scalability.

*Regularization: Reduces overfitting with regularization techniques.

Disadvantage *Complexity: Requires careful tuning of hyperparameters.

*Computationally Intensive: Can be resource-intensive, especially with large datasets
Q1.1: Write the Answer to these questions.

• What is the difference between static and dynamic variables in python?

ans) Static Variables Definition: Static variables, also known as class variables, are variables that are shared among all instances of a class.

1.Scope: They are defined within a class but outside any instance methods.

Dynamic Variables Definition: Dynamic variables, often referred to as instance variables, are unique to each instance of a class.

1.Scope: They are defined within methods, usually the' init' method, and are prefixed with 'self' to indicate they belong to the instance.

• Explain the purpose of "pop","popitem", and "clear()" in a dictionary with suitable examples.

pop Method Purpose: The pop method removes the specified key and returns the corresponding value. If the key is not found, it raises a KeyError, unless a default value is provided. ex:

print(my_dict.pop('b'))  # Output: 2
print(my_dict)  # Output: {'a': 1, 'c': 3}

print(my_dict.pop('d', 'Not Found'))  # Output: Not Found
print(my_dict)  # Output: {'a': 1, 'c': 3}
popitem Method Purpose: The popitem method removes and returns the last key-value pair as a tuple. If the dictionary is empty, it raises a KeyError.

print(my_dict.popitem())  # Output: ('c', 3)
print(my_dict)  # Output: {'a': 1, 'b': 2}
clear Method Purpose: The clear method removes all items from the dictionary, leaving it empty.

https://colab.research.google.com/drive/1hjgOanZBKDzd2bZ6wRMluW1u3AfxvCNn#scrollTo=-lPY-epTr3U9&line=1&uniqifier=1
(If you get any issue with reading it visit google colab using above link)
my_dict.clear()
print(my_dict)  # Output: {}
• What do you mean by FrozenSet? Explain it with suitable examples.

A frozenset in Python is an immutable set, meaning its elements cannot be modified after creation. It can be used as dictionary keys or set elements because it is hashable.

fs = frozenset([1, 2, 3])
print(fs)  # Output: frozenset({1, 2, 3})

my_dict = {fs: "Group 1"}
print(my_dict[fs])  # Output: Group 1
• Differentiate between mutable and immutable data types in python and give examples of mutable and immutable data types.

Mutable Data Types: List: lst = [1, 2, 3] Dictionary: dct = {'a': 1, 'b': 2} Set: st = {1, 2, 3} Immutable Data Types: string: s = "hello" Tuple: tpl = (1, 2, 3) Frozenset: fs = frozenset([1, 2, 3])

lst = [1, 2, 3]
lst.append(4)
print(lst)  # Output: [1, 2, 3, 4]

# Immutable
s = "hello"
# s[0] = 'H'  # This will raise an error
• What is init ? explain with an example.

init is a special method in Python classes, called a constructor, which is automatically invoked when a new instance of the class is created. It initializes the instance's attributes

    def __init__(self, name, age):
        self.name = name
        self.age = age

p1 = Person("Alice", 30)
print(p1.name)  # Output: Alice
print(p1.age)   # Output: 30
• What is docstring in Python?Explain with an example.

A docstring in Python is a string literal that appears right after the definition of a function, method, class, or module. It is used to document the purpose and behavior of the component.

    """This function greets the person whose name is passed as an argument."""
    return f"Hello, {name}!"

print(greet.__doc__)  # Output: This function greets the person whose name is passed as an argument.
• What are unit tests in Python?

Unit tests in Python are a way to test small parts of your code to make sure they work correctly. They help you catch bugs early and ensure that changes to your code don't break existing functionality. Here's a simple example using the unittest module:


def add(a, b):
    return a + b

class TestAddFunction(unittest.TestCase):
    def test_add(self):
        self.assertEqual(add(2, 3), 5)  # Check if add(2, 3) returns 5
        self.assertEqual(add(-1, 1), 0)  # Check if add(-1, 1) returns 0

if __name__ == '__main__':
    unittest.main()
• What is break, continue and pass in python? break Purpose: Terminates the nearest enclosing loop (for loop, while loop, or nested loops).

for i in range(5):
    if i == 3:
        break
    print(i)
# Output: 0, 1, 2
continue Purpose: Skips the current iteration of a loop and proceeds to the next iteration.

    if i == 2:
        continue
    print(i)
# Output: 0, 1, 3, 4
pass Purpose: Does nothing and acts as a placeholder where syntactically required.

    if i == 2:
        pass  # Placeholder, does nothing
    print(i)
# Output: 0, 1, 2, 3, 4
• What is the use of self in Python?

self is used inside class methods to refer to the instance (object) itself. It allows methods to access and modify instance attributes.

class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age

    def greet(self):
        return f"Hello, my name is {self.name} and I am {self.age} years old."

# Creating an instance of Person
p = Person("Alice", 30)
print(p.greet())  # Output: Hello, my name is Alice and I am 30 years old.
• What are globa , protected and private attributes in Python?

Global Attributes: Variables defined at the module level, accessible throughout the module.


def some_function():
    print(global_var)

some_function()  # Output: 10
Protected Attributes: Conventionally marked with a single leading underscore (_). It suggests that the attribute should be used within its class or module.

class MyClass:
    def __init__(self):
        self._protected_var = 20

    def get_protected_var(self):
        return self._protected_var

obj = MyClass()
print(obj.get_protected_var())  # Output: 20
Private Attributes: Indicated by a double leading underscore (__). It triggers name mangling to make the attribute less accessible from outside the class.

    def __init__(self):
        self.__private_var = 30

    def get_private_var(self):
        return self.__private_var

obj = MyClass()
# Directly accessing __private_var will raise an AttributeError
print(obj.get_private_var())  # Output: 30
• What are modules and packages in python?

Modules: Modules in Python are files containing Python code that define functions, classes, and variables. They help organize code into reusable units, making it easier to manage and maintain.

# math_operations.py
def add(a, b):
    return a + b

# main.py
import math_operations

print(math_operations.add(5, 3))  # Output: 8
Packages: Packages are directories containing multiple Python modules along with a special init.py file. They provide a way to structure and namespace Python's module namespace, allowing for hierarchical organization of code.

# my_package/module1.py
def func1():
    print("Function 1")

# my_package/module2.py
def func2():
    print("Function 2")

# main.py
from my_package import module1, module2

module1.func1()  # Output: Function 1
module2.func2()  # Output: Function 2
• What are lists and tuples? What is the key difference between the two?

Lists: Mutable sequences of elements, defined with square brackets [ ].

Tuples: Immutable sequences of elements, defined with parentheses ( ).

my_list = [1, 2, 3]

# Tuple example
my_tuple = (1, 2, 3)
• What is an Interpreted language & dynamically typed language?Write 5 differences between them.

Interpreted vs Dynamically Typed Language:

Interpreted Language: Code is executed line by line without compiling (e.g., Python). Dynamically Typed Language: Variable types are determined at runtime, allowing flexibility but potentially leading to runtime errors.

x = 5  # Integer
x = "hello"  # String
• What are Dict and List comprehensions?

Dict and List Comprehensions:

List Comprehension: Concise way to create lists based on existing lists. Dict Comprehension: Similar to list comprehension but creates dictionaries

squares = [x**2 for x in range(5)]

# Dict comprehension
square_dict = {x: x**2 for x in range(5)}
• What are decorators in Python? Explain it with an example.Write down its use cases.

Decorators:

Functions that modify the behavior of other functions or methods without changing their code. Used for adding functionalities like logging, timing, or access control.

    def wrapper():
        print("Something is happening before the function is called.")
        func()
        print("Something is happening after the function is called.")
    return wrapper

@my_decorator
def say_hello():
    print("Hello!")

say_hello()
• How is memory managed in Python?

Memory Management in Python:

Handled automatically by Python's memory manager using techniques like reference counting and garbage collection. Ensures efficient allocation and deallocation of memory.

• What is lambda in python? Why is it used?

Lambda Functions:

Small anonymous functions defined with lambda keyword. Used for short functions where def syntax is overly verbose

add = lambda x, y: x + y
print(add(3, 5))  # Output: 8
• Explain split() and join() functions in Python?

split(): Splits a string into a list of substrings based on a delimiter.

join(): Concatenates elements of an iterable into a string, with a specified separator.

sentence = "Hello, world!"
words = sentence.split(", ")  # Output: ['Hello', 'world!']
new_sentence = "-".join(words)  # Output: 'Hello-world!'
• What are iterators , iterable & generators in Python?

Iterable: Any object capable of returning its members one at a time (e.g., lists, tuples).

Iterator: Object used to iterate through an iterable using iter() and next() methods.

Generators: Functions that generate a sequence of values lazily, using yield instead of return.

def square_numbers(n):
    for i in range(n):
        yield i ** 2

my_gen = square_numbers(5)
print(list(my_gen))  # Output: [0, 1, 4, 9, 16]
• What is the difference between xrange and range in python?

range: Returns a list of numbers and stores them in memory.

xrange: Generates numbers on-the-fly, using less memory, but available only in Python 2 (in Python 3, range behaves like xrange).

for i in xrange(5):
    print(i)
• Pillars of Oops.

Pillars of OOPs:

Encapsulation: Bundling of data and methods that operate on the data.

Inheritance: Ability of a class to inherit properties and methods from another class.

Polymorphism: Ability to use a single interface for different data types or classes.

Abstraction: Hiding complex implementation details and showing only relevant information.

• How will you check if a class is a child Of another class?

Use issubclass() function to check if a class is a subclass of another class.

    pass

class Child(Parent):
    pass

print(issubclass(Child, Parent))  # Output: True
• How does inheritance work in python? Explain all types of inheritance with an example.

Inheritance in Python:

Mechanism where a new class derives attributes and methods from an existing class.

Types include single, multiple, multilevel, and hierarchical inheritance.

class Parent:
    def show(self):
        print("Parent method")

class Child(Parent):
    pass

obj = Child()
obj.show()  # Output: Parent method
• What is encapsulation? Explain it with an example.

Encapsulation is the bundling of data and methods that operate on the data into a single unit (class). Ex:

    def __init__(self, brand):
        self.brand = brand
        self.__mileage = 0  # Private attribute

    def drive(self):
        self.__mileage += 10

my_car = Car("Toyota")
my_car.drive()
# Accessing private attribute directly will raise an AttributeError
• What is polymorphism? Explain it with an example.

Polymorphism allows methods to be written in a way that they can take multiple forms or implementations. Ex:

    def sound(self):
        print("Bark")

class Cat:
    def sound(self):
        print("Meow")

def make_sound(animal):
    animal.sound()

make_sound(Dog())  # Output: Bark
make_sound(Cat())  # Output: Meow
Q1.2. Which of the following identifier names are invalid and why? Serial_no. 1st_Room Hundred$ Total_Marks total-Marks Total Marks True _ percentag

1.serial_no. -- it's valid identifier

2.1st_room -- it's invalid identifier due to having number at the begining.

3.Hundred$ - it's valid identifier

4.Total_Marks -- it's valid identifier

5.total-marks -- it's invalid identifier due to hyphens (-) are not allowed

6.Total Marks -- it's invalid identifier due to space are not allowed

7.True -- it's invalid identifier due to Keywords are not allowed

8._percentag - it's valid identifier

Question 1.3. name = ('Mohan•, "dash", "karam•, do the following operations in this list; a) add an element "freedom_fighter" in this list at the 0th index.

name_list = list(name)
name_list.insert(0, "freedom_fighter")
name = tuple(name_list)

print(name)  # Output: ('freedom_fighter', 'Mohan', 'dash', 'karam')
b) find the output of the following rand explain how?

name = ["freedeomFighter","Bapuji","MOhan","dash", "karam","chandra","gandhi"] length1 = len((name[-len(name)+1:-1:2])) length2 = len((name[-len(name)+1:-1])) print(length1+length2)

name = ["freedeomFighter", "Bapuji", "MOhan", "dash", "karam", "chandra", "gandhi"]
length1 = len(name[1:-1:2])
length2 = len(name[1:-1])
print(length1 + length2)  # Output: 8
The code calculates lengths of two slices of the list and sums them.

length1 is 3 and length2 is 5. The sum is 8.

c) Add Two more elements in the name ["Netaji","Bose"] at the end of the list

name = ["freedeomFighter", "Bapuji", "MOhan", "dash", "karam", "chandra", "gandhi"]
name.extend(["Netaji", "Bose"])
print(name)
d) What will be the value of temp: name = ["Bapuji","dash","karam","chandra","gandhi","mohan"] temp = name[-1] name[-1] =name[0] name[0] = temp print(name)

ans) (outpur) name = ['mohan', 'dash', 'karam', 'chandra', 'gandhi', 'Bapuji']

Question 1.4.Find the output of the following.

animal = ["Human","cat","mat","cat","rat","Human"] print(animal.count('Human')) print(animal.index('rat')) print(len(animal))

print(animal.count('Human')) #output 2
print(animal.index('rat')) #output 4
print(len(animal)) #output 6
Q1.5) tuple1 = (10,20,"apple",3.4,"a",["master","ji"],("sita","geeta",22),[{"roll_no":1},{"name":"Navneet"}])

a)print(len(tuple1)) b)print(tuple1[-1][-1]["name"]) c)fetch the value of rool_no from this tuple. d)print(tuple1[-3][1]) e)fetch the element "22" from this tuple.


# a) Print length of the tuple
print(len(tuple1))  # Output: 8

# b) Print the value associated with the key "name"
print(tuple1[-1][-1]["name"])  # Output: Navneet

# c) Fetch the value of "roll_no"
print(tuple1[-1][0]["roll_no"])  # Output: 1

# d) Print the second element of the seventh item in the tuple
print(tuple1[-3][1])  # Output: geeta

# e) Fetch the element "22" from the tuple
print(tuple1[-3][-1])  # Output: 22
1.6. Write a program to display the appropriate message as per the color Of signal(RED-Stop/YeIIow-Stay/Green-Go) at the road crossing.

signal = input("Enter the signal color (RED/Yellow/Green): ").strip().lower()

if signal == 'red':
    print("Stop")
elif signal == 'yellow':
    print("Stay")
elif signal == 'green':
    print("Go")
else:
    print("Invalid color")
1.7. Write a program to create a simple calculator performing only four basic perations(+,-,/,* ).

def calculator(a, b, operation):
    if operation == '+':
        return a + b
    elif operation == '-':
        return a - b
    elif operation == '*':
        return a * b
    elif operation == '/':
        return a / b
    else:
        return "Invalid operation"

a = float(input("Enter first number: "))
b = float(input("Enter second number: "))
operation = input("Enter operation (+, -, *, /): ")

result = calculator(a, b, operation)
print("The result is:", result)
1.8. Write a program to find the larger of the three pre- specified numbers using temary operators.

a, b, c = 5, 10, 3
largest = a if a > b and a > c else b if b > c else c
print("The largest number is:", largest)
1.9. Write a program to find the factors Of a whole number using a while loop.

number = int(input("Enter a whole number: "))
i = 1

while i <= number:
    if number % i == 0:
        print(i)
    i += 1
1.10. Write a program to find the sum of all the positive numbers entered by the user. As soon as the user enters a negative number, stop taking in any further input from the user and display the sum .

total = 0

while True:
    num = int(input("Enter a number: "))
    if num < 0:
        break
    total += num

print("The sum is:", total)
1.11. Write a program to find prime numbers between 2 to 100 using nested for loops.

for num in range(2, 101):
    is_prime = True
    for i in range(2, int(num ** 0.5) + 1):
        if num % i == 0:
            is_prime = False
            break
    if is_prime:
        print(num)
1.12. Write the programs for the following: Screenshot 2024-07-13 141144.png

(if image not visible)

Criteria Grade
percentage > 85 A

percentage < 85 && percentage >= 75 B

percentage < 75 && percentage >= 50 c

percentage > 30 && percentage 50 D

percentage `<30 Reappear

Q)Accept and Display Marks of Five Subjects

a)Allows the user to input marks for five subjects and stores them in a list marks, then prints the list.

# Accept marks of five subjects from the user
marks = []
for i in range(5):
    subject_marks = float(input(f"Enter marks for subject {i+1}: "))
    marks.append(subject_marks)

# Display the marks of all subjects
print("Marks obtained in five subjects:", marks)
Q)Calculate Sum and Percentage of Marks

a) Calculates the total marks and percentage based on the marks entered. It divides the total marks by 5 to get the average and then calculates the percentage, finally printing both.

# Calculate sum of marks
total_marks = sum(marks)

# Calculate percentage
percentage = (total_marks / (5 * 100)) * 100

# Display the sum and percentage
print(f"Total marks obtained: {total_marks}")
print(f"Percentage: {percentage}%")
Q)Find Grade Based on Percentage Using if-elif Statements

a)Determines the grade based on the calculated percentage using if-elif statements. It checks the percentage against predefined ranges and assigns a grade accordingly, then displays the grade.

# Determine grade based on percentage using if-elif statements
if percentage > 85:
    grade = "A"
elif percentage >= 75:
    grade = "B"
elif percentage >= 50:
    grade = "C"
elif percentage >= 30:
    grade = "D"
else:
    grade = "Reappear"

# Display the grade
print(f"Grade: {grade}")
1.13. Write a program for VIBGYOR Spectrum based on their Wavelength using. Wavelength Range:

Color Wavelength Range (nanometers)
Violet 400 - 440

Indigo 440 - 460

Blue 460 - 500

Green 500 - 570

Yellow 570 - 590

Orange 590 - 620

Red 620 - 720

wavelength = float(input("Enter the wavelength in nanometers: "))

# Determine and print the corresponding color
if 400 <= wavelength < 440:
    print("The color is Violet")
elif 440 <= wavelength < 460:
    print("The color is Indigo")
elif 460 <= wavelength < 500:
    print("The color is Blue")
elif 500 <= wavelength < 570:
    print("The color is Green")
elif 570 <= wavelength < 590:
    print("The color is Yellow")
elif 590 <= wavelength < 620:
    print("The color is Orange")
elif 620 <= wavelength <= 720:
    print("The color is Red")
else:
    print("Wavelength is outside the visible spectrum")
1.14.Consider the gravitational interactions between the Earth, Moon, and Sun in Our solar system.

Given: mass _earth = 5.972e24 # Mass of Earth in kilograms

mass _moon = 7.34767309e22 # Mass of Moon in kilograms

mass_sun=1.989e30 # Mass of Sun in kilograms

distance_earth _sun 1.496e11 # Average distance between Earth and Sun in meters

distance_ moon_earth 3.844e8 # Average distance between Moon and Earth in meters Tasks:

• Calculate the gravitational force between the Earth and the Sun.

# Constants
G = 6.67430e-11  # Gravitational constant in m^3 kg^-1 s^-2

# Given masses and distance
mass_earth = 5.972e24  # Mass of Earth in kilograms
mass_sun = 1.989e30  # Mass of Sun in kilograms
distance_earth_sun = 1.496e11  # Average distance between Earth and Sun in meters

# Calculate gravitational force between Earth and Sun
force_earth_sun = G * (mass_earth * mass_sun) / (distance_earth_sun ** 2)

print(f"The gravitational force between Earth and Sun is {force_earth_sun:.2e} Newtons")
Calculate the Gravitational Force between Moon and Earth

# Given mass and distance
mass_moon = 7.34767309e22  # Mass of Moon in kilograms
distance_moon_earth = 3.844e8  # Average distance between Moon and Earth in meters

# Calculate gravitational force between Moon and Earth
force_moon_earth = G * (mass_moon * mass_earth) / (distance_moon_earth ** 2)

print(f"The gravitational force between Moon and Earth is {force_moon_earth:.2e} Newtons")
Compare the Gravitational Forces

# Compare the gravitational forces
if force_earth_sun > force_moon_earth:
    stronger_force = "Earth and Sun"
else:
    stronger_force = "Moon and Earth"

print(f"The stronger gravitational force is between {stronger_force}")
• Explain which celestial body (Earth or Moon) is more attracted to the other based on the comparison.

1.The gravitational force between the Earth and the Sun is much stronger than the gravitational force between the Moon and the Earth.

2.This means that Earth is more attracted to the Sun than to the Moon.

3.Despite the Moon being much closer to Earth than the Sun, the Sun's significantly larger mass results in a much stronger gravitational pull on Earth compared to the Moon.

Q2. Design and implement a python program for managing student information using object—oriented principles. Create a class called -student- with encapsulated attributes for name, age, and roll number. Implement getter and setter methods for these attributes. Additionally, provide methods to display student information and update student details.

Tasks:

• Define the •Student' class with encapsulated attributes. class Student:

    def __init__(self, name, age, roll_number):
        self.__name = name
        self.__age = age
        self.__roll_number = roll_number

    # Getter methods
    def get_name(self):
        return self.__name

    def get_age(self):
        return self.__age

    def get_roll_number(self):
        return self.__roll_number

    # Setter methods
    def set_name(self, name):
        self.__name = name

    def set_age(self, age):
        self.__age = age

    def set_roll_number(self, roll_number):
        self.__roll_number = roll_number
Implement Getter and Setter Methods for the Attributes

    # Method to display student information
    def display_info(self):
        print(f"Name: {self.__name}, Age: {self.__age}, Roll Number: {self.__roll_number}")

    # Method to update student details
    def update_details(self, name=None, age=None, roll_number=None):
        if name:
            self.__name = name
        if age:
            self.__age = age
        if roll_number:
            self.__roll_number = roll_number
Create Instances Of the Student Class and Test the Implemented Functionality

# Create instances of Student class
student1 = Student("John Doe", 18, "S123")
student2 = Student("Jane Smith", 20, "S456")

# Display initial information
student1.display_info()
student2.display_info()

# Update student1's details
student1.set_age(19)
student1.update_details(name="Johnathan Doe")

# Display updated information
student1.display_info()
Q3.Develop a python program for managing library resources efficiently. Design a class named -LibraryB00kwith attributes like book name, author, and availability Status. Implement methods for borrowing and returning books while ensuring proper encapsulation Of attributes.

Tasks:

• Create the -LibraryBook' class with encapsulated attributes.

class LibraryBook:
    def __init__(self, book_name, author, availability=True):
        self.__book_name = book_name
        self.__author = author
        self.__availability = availability
Implement Methods for Borrowing and Returning Books

    def borrow_book(self):
        if self.__availability:
            self.__availability = False
            print(f"Borrowed: {self.__book_name}")
        else:
            print(f"Sorry, {self.__book_name} is not available.")

    def return_book(self):
        if not self.__availability:
            self.__availability = True
            print(f"Returned: {self.__book_name}")
        else:
            print(f"{self.__book_name} was not borrowed.")
Ensure Proper Encapsulation to Protect Book Details

    def get_details(self):
        return f"Book: {self__book_name}, Author: {self.__author}, Available: {self.__availability}"
Test the Borrowing and Returning Functionality with Sample Data

book1 = LibraryBook("Python Programming", "John Doe")
book2 = LibraryBook("Data Structures", "Jane Smith", False)

# Test borrowing and returning
print(book1.get_details())
book1.borrow_book()
print(book1.get_details())
book1.return_book()
print(book1.get_details())

print(book2.get_details())
book2.borrow_book()
book2.return_book()
Q4.Create a simple banking System using Object-oriented concepts in python. Design classes representing different types Of bank accounts such as savings and checking. Implement methods for deposit, withdraw, and balance inquiry. Utilize inheritance to manage different account types efficiently.

Tasks:

• 1. Define base class(es) for bank accounts with common attributes and methods.

class BankAccount:
    def __init__(self, account_holder, balance=0):
        self.account_holder = account_holder
        self.balance = balance

    def deposit(self, amount):
        self.balance += amount
        print(f"Deposited {amount}. New balance: {self.balance}")

    def withdraw(self, amount):
        if amount > self.balance:
            print("Insufficient funds.")
        else:
            self.balance -= amount
            print(f"Withdrew {amount}. New balance: {self.balance}")

    def get_balance(self):
        return self.balance
Implement Subclasses for Specific Account Types
class SavingsAccount(BankAccount):
 def __init__(self, account_holder, balance=0):
     super().__init__(account_holder, balance)
class CheckingAccount(BankAccount):
 def __init__(self, account_holder, balance=0):
     super().__init__(account_holder, balance)
Provide Methods for Deposit, Withdraw, and Balance Inquiry in Each Subclass
a3)Methods are inherited from the base class, so no need to redefine them.

Test the Banking System by Creating Instances of Different Account Types and Performing Transactions
savings = SavingsAccount("Alice", 1000)
checking = CheckingAccount("Bob", 500)

# Test deposit, withdraw, and balance inquiry
savings.deposit(500)
savings.withdraw(200)
print(f"Savings Account Balance: {savings.get_balance()}")

checking.deposit(300)
checking.withdraw(800)
print(f"Checking Account Balance: {checking.get_balance()}")
Q5)Write a python program that models different animals and their sounds. Design a base class called •Animal* with a method Create subclasses like 'Dog' and 'Cat' that override the method to produce appropriate sounds.

Tasks:

•1. Define the Animal Class with a Method make_sound

class Animal:
    def make_sound(self):
        pass
Create Subclasses Dog and Cat that Override the make_sound Method

class Dog(Animal):
 def make_sound(self):
     return "Woof!"
class Cat(Animal):
 def make_sound(self):
     return "Meow!"
Implement the Sound Generation Logic for Each Subclass

A)Sound logic is implemented in the overridden make_sound methods of the subclasses.

Test the Program by Creating Instances of Dog and Cat and Calling the make_sound Method
# Create instances of Dog and Cat
dog = Dog()
cat = Cat()
# Call the make_sound method
print(dog.make_sound())  # Outputs: Woof!
print(cat.make_sound())  # Outputs: Meow!
Q6.Write a code for Restaurant Management System Using OOPS:

• Create a Menultem class that has attributes such as name, description, price, and category.

class MenuItem:
    def __init__(self, name, description, price, category):
        self.__id = id(self)
        self.name = name
        self.description = description
        self.price = price
        self.category = category
    def get_id(self):
        return self.__id
Implement Methods to Add, Update, and Remove Menu Items

class Menu:
    def __init__(self):
        self.items = []

    def add_item(self, item):
        self.items.append(item)

    def update_item(self, item_id, name=None, description=None, price=None, category=None):
        for item in self.items:
            if item.get_id() == item_id:
                if name: item.name = name
                if description: item.description = description
                if price: item.price = price
                if category: item.category = category
                break

    def remove_item(self, item_id):
        self.items = [item for item in self.items if item.get_id() != item_id]
Q)Use Encapsulation to Hide the Menu Item's Unique ID

A)The unique ID is hidden within the MenuItem class and accessed via the get_id method.

Q)Inherit from the MenuItem Class to Create FoodItem and BeverageItem Classes

class FoodItem(MenuItem):
    def __init__(self, name, description, price, category, cuisine_type):
        super().__init__(name, description, price, category)
        self.cuisine_type = cuisine_type

class BeverageItem(MenuItem):
    def __init__(self, name, description, price, category, size):
        super().__init__(name, description, price, category)
        self.size = size


# test and implimentations
# Create Menu
menu = Menu()

# Add Items
food = FoodItem("Burger", "Cheeseburger", 5.99, "Food", "American")
beverage = BeverageItem("Coke", "Coca-Cola", 1.99, "Beverage", "500ml")
menu.add_item(food)
menu.add_item(beverage)

# Update Item
menu.update_item(food.get_id(), price=6.99)

# Remove Item
menu.remove_item(beverage.get_id())

# Display Menu
for item in menu.items:
    print(f"{item.name}: ${item.price}")
7.Write a code for Hotel Management System using OOPS :

• Create a Room class that has attributes such as room number, room type, rate, and availability (private).

class Room:
    def __init__(self, room_number, room_type, rate):
        self.__id = id(self)
        self.room_number = room_number
        self.room_type = room_type
        self.rate = rate
        self.__availability = True

    def get_id(self):
        return self.__id

    def is_available(self):
        return self.__availability

    def book_room(self):
        if self.__availability:
            self.__availability = False
            return True
        return False

    def check_in(self):
        if not self.__availability:
            self.__availability = True
            return True
        return False

    def check_out(self):
        self.__availability = True
• Inherit from the Room class to create a SuiteRoom class and a StandardRoom class, each with their own specific attributes and methods.

class SuiteRoom(Room):
    def __init__(self, room_number, rate, amenities):
        super().__init__(room_number, "Suite", rate)
        self.amenities = amenities

class StandardRoom(Room):
    def __init__(self, room_number, rate):
        super().__init__(room_number, "Standard", rate)
• Implement methods to book a room, check in a guest, and check out a guest

a)Methods are already implemented in the Room class: book_room, check_in, and check_out

8.Write a code for Fitness Club Management System using OOPS:

• Create a Member class that has attributes such as name, age, membership type, and membership status (private).

class Member:
    def __init__(self, name, age, membership_type):
        self.__id = id(self)
        self.name = name
        self.age = age
        self.membership_type = membership_type
        self.__status = "Active"

    def get_id(self):
        return self.__id

    def get_status(self):
        return self.__status

    def register(self):
        self.__status = "Active"

    def renew_membership(self):
        self.__status = "Renewed"

    def cancel_membership(self):
        self.__status = "Cancelled"
Inherit from the Member Class to Create FamilyMember and IndividualMember Classes

class FamilyMember(Member):
    def __init__(self, name, age, membership_type, family_size):
        super().__init__(name, age, membership_type)
        self.family_size = family_size

class IndividualMember(Member):
    def __init__(self, name, age, membership_type):
        super().__init__(name, age, membership_type)
q)Implement Methods to Register, Renew, and Cancel Membership

a)Methods register, renew_membership, and cancel_membership are already implemented in the Member class

# Test the Implementation
# Create Members
family_member = FamilyMember("John Doe", 40, "Family", 4)
individual_member = IndividualMember("Jane Smith", 30, "Individual")

# Register Members
family_member.register()
individual_member.register()

# Renew Membership
family_member.renew_membership()

# Cancel Membership
individual_member.cancel_membership()

# Check Membership Status
print(family_member.get_status())  # Renewed
print(individual_member.get_status())  # Cancelled
Q9.Write a code for Event Management System using OOPS:

• Create an Event class that has attributes such as name, date, time, location, and list of attendees (private).

class Event:
    def __init__(self, name, date, time, location):
        self.__id = id(self)
        self.name = name
        self.date = date
        self.time = time
        self.location = location
        self.__attendees = []

    def get_id(self):
        return self.__id

    def add_attendee(self, attendee):
        self.__attendees.append(attendee)

    def remove_attendee(self, attendee):
        self.__attendees.remove(attendee)

    def get_total_attendees(self):
        return len(self.__attendees)
Inherit from the Event Class to Create PrivateEvent and PublicEvent Classes

class PrivateEvent(Event):
    def __init__(self, name, date, time, location, invite_only):
        super().__init__(name, date, time, location)
        self.invite_only = invite_only

class PublicEvent(Event):
    def __init__(self, name, date, time, location, max_capacity):
        super().__init__(name, date, time, location)
        self.max_capacity = max_capacity
Q)Implement Methods to Create, Add/Remove Attendees, and Get Total Number of Attendees

A)Methods add_attendee, remove_attendee, and get_total_attendees are already implemented in the Event class.

# Test and implementation

# Create Events
private_event = PrivateEvent("Birthday Party", "2024-08-20", "18:00", "John's House", True)
public_event = PublicEvent("Concert", "2024-09-15", "20:00", "Central Park", 500)

# Add Attendees
private_event.add_attendee("Alice")
private_event.add_attendee("Bob")
public_event.add_attendee("Charlie")

# Remove Attendee
private_event.remove_attendee("Bob")

# Get Total Attendees
print(private_event.get_total_attendees())  # 1
print(public_event.get_total_attendees())  # 1
Q10.Write a code for Airline Reservation System using OOPS:

• Create a Flight class that has attributes such as flight number, departure and arrival airports, departure and arrival times, and available seats (private).

class Flight:
    def __init__(self, flight_number, departure_airport, arrival_airport, departure_time, arrival_time, total_seats):
        self.__id = id(self)
        self.flight_number = flight_number
        self.departure_airport = departure_airport
        self.arrival_airport = arrival_airport
        self.departure_time = departure_time
        self.arrival_time = arrival_time
        self.__available_seats = total_seats

    def get_id(self):
        return self.__id

    def book_seat(self):
        if self.__available_seats > 0:
            self.__available_seats -= 1
            return True
        else:
            return False

    def cancel_reservation(self):
        if self.__available_seats < total_seats:
            self.__available_seats += 1
            return True
        else:
            return False

    def get_available_seats(self):
        return self.__available_seats
Inherit from the Flight Class to Create DomesticFlight and InternationalFlight Classes

class DomesticFlight(Flight):
    def __init__(self, flight_number, departure_airport, arrival_airport, departure_time, arrival_time, total_seats, baggage_allowance):
        super().__init__(flight_number, departure_airport, arrival_airport, departure_time, arrival_time, total_seats)
        self.baggage_allowance = baggage_allowance

class InternationalFlight(Flight):
    def __init__(self, flight_number, departure_airport, arrival_airport, departure_time, arrival_time, total_seats, meal_service):
        super().__init__(flight_number, departure_airport, arrival_airport, departure_time, arrival_time, total_seats)
        self.meal_service = meal_service
q)Implement Methods to Book a Seat, Cancel a Reservation, and Get Remaining Available Seats

a)Methods book_seat, cancel_reservation, and get_available_seats are already implemented in the Flight class.

# test and implementation
# Create Flights
domestic_flight = DomesticFlight("DF101", "JFK", "LAX", "10:00", "14:00", 150, "20 kg")
international_flight = InternationalFlight("IF202", "LHR", "JFK", "08:00", "16:00", 200, "Standard Meal")

# Book Seats
print(domestic_flight.book_seat())  # True (Seat booked)
print(international_flight.book_seat())  # True (Seat booked)

# Cancel Reservation
print(domestic_flight.cancel_reservation())  # True (Reservation cancelled)

# Get Available Seats
print(domestic_flight.get_available_seats())  # 149
print(international_flight.get_available_seats())  # 199
Q)11. Define a python module named constants.py containing constants like pi and the speed Of light.

# constants.py
PI = 3.14159
SPEED_OF_LIGHT = 299792458  # meters per second
q12. Write a python module named calculator.py containing functions for addition, subtraction, multiplication, and division.

# calculator.py
def add(a, b):
    return a + b

def subtract(a, b):
    return a - b

def multiply(a, b):
    return a * b

def divide(a, b):
    if b != 0:
        return a / b
    else:
        return "Error: Division by zero"
q13. Implement a Python package structure for a project named ecommerce, containing modules for product management and order processing.

ecommerce/
    __init__.py
    product_management.py
    order_processing.py
q14. Implement a python module named string_utils.py containing functions for string manipulation, such as reversing and capitalizing strings.

# string_utils.py
def reverse_string(s):
    return s[::-1]

def capitalize_string(s):
    return s.capitalize()
q15) Write a Python module named file_operations.py with functions for reading, writing, and appending data to a file.

# file_operations.py
def read_file(filename):
    with open(filename, 'r') as file:
        return file.read()

def write_to_file(filename, data):
    with open(filename, 'w') as file:
        file.write(data)

def append_to_file(filename, data):
    with open(filename, 'a') as file:
        file.write(data + '\n')
q16. Write a python program to create a text file named "employees.txt" and write the details Of employees, including their name, age, and salary, into the file.

# Creating employees.txt
with open("employees.txt", 'w') as file:
    file.write("Name: John Doe\nAge: 30\nSalary: $50000\n")
    file.write("Name: Jane Smith\nAge: 25\nSalary: $45000\n")
q17. Develop a python script that opens an existing text file named "inventory.txt" in read mode and displays the contents Of the file line by line.

# Reading inventory.txt
with open("inventory.txt", 'r') as file:
    for line in file:
        print(line.strip())
q18. Create a python script that reads a text file named "expenses.txt" and calculates the total amount spent on various expenses listed in the file.

# Calculating total expenses from expenses.txt
total_expenses = 0
with open("expenses.txt", 'r') as file:
    for line in file:
        try:
            expense = float(line.strip().split()[1])  # Assuming format is 'Expense: amount'
            total_expenses += expense
        except ValueError:
            pass  # Ignore lines that don't match expected format

print(f"Total expenses: ${total_expenses}")
q19. Create a python program that reads a text file named "paragraph.txt" and counts the occurrences Of each word in the paragraph, displaying the results in alphabetical order.

# Counting word occurrences in paragraph.txt
from collections import defaultdict

word_counts = defaultdict(int)
with open("paragraph.txt", 'r') as file:
    for line in file:
        words = line.strip().split()
        for word in words:
            word_counts[word.lower()] += 1

# Display results in alphabetical order
for word in sorted(word_counts):
    print(f"{word}: {word_counts[word]}")
q20. What do you mean by Measure of Central Tendency and Measures of Dispersion. How it can be calculated. a)Measure of Central Tendency:

Mean: Sum of values divided by the number of values. Median: Middle value when values are sorted. Mode: Most frequently occurring value. Measures of Dispersion:

Range: Difference between the maximum and minimum values. Variance: Average of squared differences from the mean. Standard Deviation: Square root of variance.

q21. What do you mean by skewness. Explain its types and use graph to show.

a)Skewness:

Measures asymmetry in data distribution. Positive skew: Tail on the right side of the distribution.

Negative skew: Tail on the left side of the distribution.

Graphically, positive skew means the mean > median > mode, and negative skew means the mode > median > mean.

q22. Explain PROBABILITY MASS FUNCTION (PMF) and PROBABILITY DENSITY FUNCTION (PDF), and what is the difference between them?

a)PMF: Probability distribution of discrete random variables.

PDF: Probability distribution of continuous random variables.

PMF gives probabilities for discrete outcomes, while PDF gives probabilities for continuous outcomes. PDF is also the derivative of the cumulative distribution function (CDF).

q23. What is correlation. Explain its types in detail and what are the methods of determining correlation.

Correlation:

Measures strength and direction of relationship between two variables.

Types: Pearson correlation (linear relationship), Spearman correlation (monotonic relationship), Kendall correlation (ordinal variables).

Methods: Calculate correlation coefficient (ranges from -1 to 1), visualize with scatter plots, and test significance with hypothesis tests like t-test or p-value.

Calculate coefficient of correlation between the marks obtained by 10 students in Accountancy and statistics:

student: 1 2 3 4 5 6 7 8 9 10

Accountancy 45 70 65 30 90 40 50 75 85 60

statistics 35 90 70 40 95 40 60 80 80 50

a) the coefficient of correlation (Pearson's correlation coefficient) between the marks obtained in Accountancy and Statistics for 10 students

import numpy as np

# Marks data
accountancy_marks = np.array([45, 70, 65, 30, 90, 40, 50, 75, 85, 60])
statistics_marks = np.array([35, 90, 70, 40, 95, 40, 60, 80, 80, 50])

# Calculate Pearson correlation coefficient
correlation_coefficient = np.corrcoef(accountancy_marks, statistics_marks)[0, 1]

print(f"Pearson's correlation coefficient: {correlation_coefficient}")
q25. Discuss the 4 differences between correlation and regression.

a)Purpose: Correlation measures the strength and direction of the relationship between two variables. Regression predicts the value of one variable based on another.

Nature: Correlation is symmetrical; it measures the association between variables without implying causation. Regression is directional; it establishes a predictive model.

Variables: Correlation involves two variables treated equally. Regression distinguishes between independent (predictor) and dependent (outcome) variables.

Output: Correlation produces a correlation coefficient. Regression gives an equation to predict values.

Q26. Find the most likely price at Delhi corresponding to the price of Rs. 70 at Agra from the following data: Coefficient of correlation between the prices of the two places +0.8.

A)Given a correlation coefficient of +0.8 between Agra and Delhi prices, to find the price at Delhi corresponding to Rs. 70 at Agra, use regression or the correlation coefficient directly. If Rs. 70 at Agra corresponds to a high positive correlation, a likely price at Delhi could be higher than Rs. 70.

q27) In a partially destroyed laboratory record of an analysis of correlation data, the following results only are legible: Variance of x = 9, Regression equations are: (i) 8x-10y = —66; (ii) 40x -18y = 214. What are (a) the mean values of x and y, (b) the coefficient of correlation between x and y, (c) the c of y.

import numpy as np
from sympy import symbols, Eq, solve

# (a) Mean values of x and y

# Given regression equations
# 8x - 10y = -66
# 40x - 18y = 214

# Define symbols
x, y = symbols('x y')

# Define the equations
eq1 = Eq(8*x - 10*y, -66)
eq2 = Eq(40*x - 18*y, 214)

# Solve the equations simultaneously
solution = solve((eq1, eq2), (x, y))

mean_x = solution[x]
mean_y = solution[y]

print(f"Mean of x: {mean_x}")
print(f"Mean of y: {mean_y}")

# (b) Coefficient of correlation between x and y

# Given regression coefficients
b_yx = 8 / 10
b_xy = 18 / 40

# Correlation coefficient r
r = np.sqrt(b_yx * b_xy)

print(f"Correlation coefficient: {r}")

# (c) Constant of y

# Using mean values and regression coefficient
a = mean_y - b_yx * mean_x

print(f"Constant of y: {a}")
q28. What is Normal Distribution? What are the four Assumptions of Normal Distribution? Explain in detail.

a)Normal distribution is a bell-shaped curve that's symmetric around the mean. It's often called the Gaussian distribution. The mean, median, and mode are all equal and located at the center of the distribution.

Four Assumptions of Normal Distribution:

Symmetry: The distribution is symmetric around the mean.

Equal Mean, Median, and Mode: These measures of central tendency are all the same.

Asymptotic: The tails of the distribution approach the horizontal axis but never touch it.

Defined by Mean and Standard Deviation: The distribution's shape is determined by these two parameters.

Q29.Write all the characteristics or properties of the Normal Distribution Curve.

A)Characteristics of the Normal Distribution Curve

Symmetry: The curve is symmetric around the mean.

Mean, Median, and Mode: All are equal and located at the center.

Bell-shaped: The curve has a single peak at the mean.

Asymptotic: The tails approach the horizontal axis but never touch it.

Empirical Rule: About 68% of the data falls within one standard deviation of the mean, 95% within two, and 99.7% within three.

Q30)Which of the following options are correct about Normal Distribution Curve

(a) Within a range 0.6745 of o on both sides the middle 50% of the observations occur i,e. mean *0.67450 covers 50% area 25% on each side.

a): False. The correct range for covering 50% of the area is within ±0.6745σ, not μ×0.6745.

(b) Mean ±IS.D. (i,e.p ± 10) covers 68.268% area, 34.134 % area lies on either side of the mean.

b): True. μ±1σ covers approximately 68.268% of the area under the normal distribution curve.

(c) Mean ±2S.D. (i,e. ± 20) covers 95.45% area, 47.725% area lies on either side of the mean. (c): True.μ±2σ covers approximately 95.45% of the area under the normal distribution curve

(d) Mean S.D. (i,e. p ±30) covers 99.73% area, 49.856% area lies on the either side of the mean.

d) Mean S.D. (i,e. p ±30) covers 99.73% area, 49.856% area lies on the either side of the mean.

(e) Only 0.27% area is outside the range p *3.0

e): True. Only 0.27% of the area is outside the range μ±3σ.

Q31) The mean of a distribution is 60 with a standard deviation of 10. Assuming that the distribution is normal, what percentage of items be (i) between 60 and 72, (ii) between 50 and 60, (iii) beyond 72 and (iv) between 70 and 80? a)

Given: Mean = 60, Standard Deviation = 10.

(i) Between 60 and 72:
   - Use the Z-score formula: \( Z = \frac{X - \mu}{\sigma} \)
   - Calculate Z-scores: \( Z_{60} = \frac{60 - 60}{10} = 0 \),
     \( Z_{72} = \frac{72 - 60}{10} = 1.2 \).
   - Look up Z-table or use Python's scipy.stats.norm.cdf() function.
   - Approximate percentage: Around 21.22%.

(ii) Between 50 and 60:
   - Z-scores: \( Z_{50} = \frac{50 - 60}{10} = -1 \),
     \( Z_{60} = 0 \).
   - Approximate percentage: Around 34.13%.

(iii) Beyond 72 (greater than 72):
   - Z-score for 72: \( Z_{72} = 1.2 \).
   - Use complement rule: \( 1 - \text{cdf}(Z_{72}) \).
   - Approximate percentage: Around 11.35%.

(iv) Between 70 and 80:
   - Z-scores: \( Z_{70} = \frac{70 - 60}{10} = 1 \),
     \( Z_{80} = \frac{80 - 60}{10} = 2 \).
   - Approximate percentage: Around 31.73%.
.
q32. 15000 students sat for an examination. The mean marks was 49 and the distribution of marks had a standard deviation of 6. Assuming that the marks were normally distributed what proportion of students scored (a) more than 55 marks, (b) more than 70 marks

Given: Mean = 49, Standard Deviation = 6, Total students = 15000.

(a) Proportion of students scoring more than 55 marks:
   - Z-score for 55: \( Z_{55} = \frac{55 - 49}{6} = 1 \).
   - Use complement rule: \( 1 - \text{cdf}(Z_{55}) \).
   - Approximate percentage: Around 15.87%.

(b) Proportion of students scoring more than 70 marks:
   - Z-score for 70: \( Z_{70} = \frac{70 - 49}{6} = 3.5 \).
   - Use complement rule: \( 1 - \text{cdf}(Z_{70}) \).
   - Approximate percentage: Around 0.03%.
If the height of 500 students are normally distributed with mean 65 inch and standard deviation 5 inch. How many students have height : a) greater than 70 inch. b) between 60 and 70 inch.
Given: Mean = 65 inches, Standard Deviation = 5 inches, Total students = 500.

(a) Number of students with height greater than 70 inches:
   - Z-score for 70 inches: \( Z_{70} = \frac{70 - 65}{5} = 1 \).
   - Use the complement rule: \( 1 - \text{cdf}(Z_{70}) \).
   - Approximate percentage: Around 15.87%.
   - Number of students: \( \text{Total students} \times \text{Percentage} = 500 \times 0.1587 = 79.35 \).

   Since you can't have a fraction of a student, round to the nearest whole number:
   - Number of students greater than 70 inches: Approximately 79.

(b) Number of students with height between 60 and 70 inches:
   - Z-score for 60 inches: \( Z_{60} = \frac{60 - 65}{5} = -1 \).
   - Z-score for 70 inches: \( Z_{70} = \frac{70 - 65}{5} = 1 \).
   - Calculate the area between these two Z-scores using the difference of cdf values:
     \( \text{cdf}(Z_{70}) - \text{cdf}(Z_{60}) \).
   - Approximate percentage: Around 68.27%.
   - Number of students: \( 500 \times 0.6827 = 341.35 \).

   Round to the nearest whole number:
   - Number of students between 60 and 70 inches: Approximately 341.
35.A random sample of size 25 from a population gives the sample standard derivation to be 9.0. Test the hypothesis that the population standard derivation is 10.5. Hint(use chi- square distribution).

statistical hypothesis a)Statistical hypothesis is a statement o r assumption about the population parameters, tested using statistical methods to determine if there is enough evidence to reject or fail to reject the null hypothesis (H₀).

Errors in Hypothesis Testing: Type I Error: Occurs when we reject the null hypothesis (H₀) when it is actually true. It's a false positive.

Type II Error: Occurs when we fail to reject the null hypothesis (H₀) when it is actually false. It's a false negative.

Sample Explanation: Sample: A subset of individuals or objects selected from a larger population to represent it in a study or experiment.

Large Samples vs. Small Samples:

Large Samples: Typically have more than 30 observations. They tend to provide more reliable estimates of population parameters and are less affected by random fluctuations.

Small Samples: Usually have fewer than 30 observations. They can still provide insights but are more susceptible to random variability, making generalizations to the population more challenging.

Q37)100 students of a PW 101 obtained the following grades in Data Science paper : Grade : [A,B, C, D, E]

Total Frequency : [15,17, 30, 22, 16, 100]

Using the X(sigma)2 test , examine the hypothesis that the distribution of grades is uniform.

a)x`Given Data:

Grades: A, B, C, D, E

Frequencies: 15, 17, 30, 22, 16

Total students: 100

Calculate Expected Frequencies:

If the distribution were uniform, each grade would have an expected frequency of 100/5=20.

Set up Hypotheses:

Null Hypothesis (H₀): The distribution of grades is uniform.

Alternative Hypothesis (H₁): The distribution of grades is not uniform.

Compute Chi-square Statistic:

𝜒2=∑(𝑂𝑖−𝐸𝑖)2/Ei, where Oi is the observed frequency and Ei is the expected frequency for each grade.

Degrees of Freedom:

Degrees of freedom (df) = Number of categories - 1 = 5 - 1 = 4.

Compare with Critical Value: Use a Chi-square table or function (like scipy.stats.chi2) to find the critical value for χ2 with 4 degrees of freedom at a chosen significance level (e.g., 0.05).

Q36) Not Available in assignment PDF

Double-click (or enter) to edit

q38.Anova Test: TO study the performance Of three detergents and three different water temperatures the following whiteness readings were obtained with specially designed equipment.

Water temp | Detergents A | Detergents B | Detergents C

Cold Water | 57 | 55 | 67

Worm Water | 49 | 52 | 68

Hot Water | 54 | 46 | 58

Data:

Cold Water: [57, 55, 67]

Warm Water: [49, 52, 68]

Hot Water: [54, 46, 58]

Hypotheses:

H₀: No difference in mean whiteness among detergents and water temperatures. H₁: At least one mean whiteness is different

import pandas as pd
import scipy.stats as stats

# Data
data = {
    'Detergent A': [57, 49, 54],
    'Detergent B': [55, 52, 46],
    'Detergent C': [67, 68, 58]
}

df = pd.DataFrame(data, index=['Cold Water', 'Warm Water', 'Hot Water'])

# Reshape data for ANOVA
df_melt = pd.melt(df.reset_index(), id_vars=['index'], value_vars=['Detergent A', 'Detergent B', 'Detergent C'])
df_melt.columns = ['Water_Temperature', 'Detergent', 'Whiteness']

# ANOVA test
anova_result = stats.f_oneway(
    df_melt[df_melt['Detergent'] == 'Detergent A']['Whiteness'],
    df_melt[df_melt['Detergent'] == 'Detergent B']['Whiteness'],
    df_melt[df_melt['Detergent'] == 'Detergent C']['Whiteness']
)

anova_result
Q39.How would you create a basic Flask route that displays "Hello, World!" on the homepage?

# !pip install Flask
# Import Flask
from flask import Flask

# Create Flask app
app = Flask(__name__)

# Define route for homepage
@app.route('/')
def home():
    return "Hello, World!"

# Run the app
if __name__ == '__main__':
    app.run()
q40.Explain how to set up a Flask application to handle form submissions using POST requests.

from flask import Flask, request, render_template_string

app = Flask(__name__)

# Define the form template
form_template = '''
<!doctype html>
<html>
<body>
    <form method="POST" action="/">
        <input type="text" name="name">
        <input type="submit">
    </form>
</body>
</html>
'''

# Define the route to display the form
@app.route('/', methods=['GET', 'POST'])
def form():
    if request.method == 'POST':
        name = request.form['name']
        return f"Hello, {name}!"
    return render_template_string(form_template)

# Run the app
if __name__ == '__main__':
    app.run()
q41.Write a Flask route that accepts a parameter in the URL and displays it on the page.

from flask import Flask

app = Flask(__name__)

# Define the route with a parameter
@app.route('/hello/<name>')
def hello(name):
    return f"Hello, {name}!"

# Run the app
if __name__ == '__main__':
    app.run()
Q42.How can you implement user authentication in a Flask application?

!pip install Flask Flask-Login
from flask import Flask, render_template_string, redirect, url_for, request
from flask_login import LoginManager, UserMixin, login_user, login_required, logout_user, current_user

app = Flask(__name__)
app.secret_key = 'secretkey'
login_manager = LoginManager()
login_manager.init_app(app)

# User class
class User(UserMixin):
    def __init__(self, id):
        self.id = id

# User loader
@login_manager.user_loader
def load_user(user_id):
    return User(user_id)

# Login route
@app.route('/login', methods=['GET', 'POST'])
def login():
    if request.method == 'POST':
        user = User(request.form['username'])
        login_user(user)
        return redirect(url_for('protected'))
    return '''
    <form method="POST" action="/login">
        <input type="text" name="username">
        <input type="submit">
    </form>
    '''

# Protected route
@app.route('/protected')
@login_required
def protected():
    return f'Logged in as: {current_user.id}'

# Logout route
@app.route('/logout')
@login_required
def logout():
    logout_user()
    return 'Logged out!'

# Run the app
if __name__ == '__main__':
    app.run()
Q43.Describe the process of connecting a Flask app to a SQLite database using SQLAIchemy.

!pip install Flask-SQLAlchemy
from flask import Flask
from flask_sqlalchemy import SQLAlchemy

app = Flask(__name__)
app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///test.db'
db = SQLAlchemy(app)

# Define a model
class User(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    username = db.Column(db.String(80), unique=True, nullable=False)

# Create the database and tables
with app.app_context():
    db.create_all()

# Run the app
if __name__ == '__main__':
    app.run()
q44.How would you create a RESTful API endpoint in Flask that returns JSON data?

!pip install Flask
from flask import Flask, jsonify

app = Flask(__name__)

@app.route("/api/data", methods=['GET'])
def get_data():
    data = {'key': 'value', 'number': 42}
    return jsonify(data)

# Run the app
if __name__ == '__main__':
    app.run()
Q45.Explain how to use Flask—WTF to create and validate forms in a Flask application.

!pip install Flask-WTF
from flask import Flask, render_template_string, request
from flask_wtf import FlaskForm
from wtforms import StringField, SubmitField
from wtforms.validators import DataRequired

app = Flask(__name__)
app.secret_key = 'secretkey'

class MyForm(FlaskForm):
    name = StringField('Name', validators=[DataRequired()])
    submit = SubmitField('Submit')

@app.route('/', methods=['GET', 'POST'])
def form():
    form = MyForm()
    if form.validate_on_submit():
        return f"Hello, {form.name.data}!"
    return render_template_string('''
    <form method="POST">
        {{ form.hidden_tag() }}
        {{ form.name.label }} {{ form.name() }}
        {{ form.submit() }}
    </form>
    ''', form=form)

# Run the app
if __name__ == '__main__':
    app.run()
Q46.How can you implement file uploads in a Flask application?

!pip install Flask
from flask import Flask, request, render_template_string

app = Flask(__name__)
app.config['UPLOAD_FOLDER'] = '/path/to/upload'

@app.route('/', methods=['GET', 'POST'])
def upload_file():
    if request.method == 'POST':
        file = request.files['file']
        if file:
            file.save(os.path.join(app.config['UPLOAD_FOLDER'], file.filename))
            return 'File uploaded successfully'
    return '''
    <form method="POST" enctype="multipart/form-data">
        <input type="file" name="file">
        <input type="submit">
    </form>
    '''

# Run the app
if __name__ == '__main__':
    app.run()
Q47.Describe the Steps to create a Flask blueprint and why you might use one.

!pip install Flask
from flask import Flask, Blueprint

# Create a blueprint
my_blueprint = Blueprint('my_blueprint', __name__)

@my_blueprint.route('/hello')
def hello():
    return "Hello from blueprint!"

# Create Flask app
app = Flask(__name__)
app.register_blueprint(my_blueprint, url_prefix='/blueprint')

# Run the app
if __name__ == '__main__':
    app.run()
use a blueprint Organizes code into modular components.

Makes the app easier to manage and scale.

Q48.How would you deploy a Flask application to a production server using Gunicorn and Nginx?

# Install Gunicorn:
pip install gunicorn
# Run Flask app with Gunicorn:
gunicorn -w 4 myapp:app
# Nginx configuration:
# Edit /etc/nginx/sites-available/myapp:
server {
    listen 80;
    server_name your_domain;

    location / {
        proxy_pass http://127.0.0.1:8000;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }
}
# Enable Nginx site:
sudo ln -s /etc/nginx/sites-available/myapp /etc/nginx/sites-enabled
sudo systemctl restart nginx
Q49. Make a fully functional web application using flask, Mangodb. Signup,Signin page.And after successfully login Say hello Geeks message at webpage.

!pip install Flask Flask-PyMongo Flask-Bcrypt Flask-Login
# Flask app with MongoDB:
from flask import Flask, render_template_string, request, redirect, url_for
from flask_pymongo import PyMongo
from flask_bcrypt import Bcrypt
from flask_login import LoginManager, UserMixin, login_user, login_required, logout_user, current_user

app = Flask(__name__)
app.config['MONGO_URI'] = 'mongodb://localhost:27017/mydatabase'
app
50.Machine Learning:

• What is the difference between Series & Dataframes .

-*Series: A one-dimensional labeled array capable of holding any data type.

*DataFrame: A two-dimensional labeled data structure with columns of potentially different types.

• Create a database name Travel_planner in mysql ,and create a table name bookings in that which having attributes (user_id INT, flight_id INT, activity_id DATE) fill with some dummy value -Now you have to read the content of this table using pandas as dataframe.Show the output.

CREATE DATABASE Travel_planner;
USE Travel_planner;
CREATE TABLE bookings (
    user_id INT,
    flight_id INT,
    activity_date DATE
);
INSERT INTO bookings (user_id, flight_id, activity_date) VALUES 
(1, 101, '2023-07-01'),
(2, 102, '2023-07-02'),
(3, 103, '2023-07-03');
!pip install pymysql sqlalchemy pandas

import pandas as pd
from sqlalchemy import create_engine

# Create engine
engine = create_engine('mysql+pymysql://username:password@localhost/Travel_planner')

# Read table into DataFrame
df = pd.read_sql('SELECT * FROM bookings', engine)
print(df)
• Difference between loc and iloc.

- *loc: Access a group of rows and columns by labels or a boolean array.

*iloc: Access a group of rows and columns by integer positions (indices).

• What is the difference between supervised and unsupervised learning?

- *Supervised Learning: The model is trained on labeled data (input-output pairs).

*Unsupervised Learning: The model is trained on unlabeled data and finds hidden patterns or intrinsic structures.

• Explain the bias-variance tradeoff.

-*Bias: Error due to overly simplistic models, missing patterns.

*Variance: Error due to overly complex models, capturing noise.

*Tradeoff: Aim to find a balance; too much bias misses patterns, too much variance overfits.

• What are precision and recall? How are they different from accuracy?

- **Precision: True Positives/ True Positives+False Positives

**Recall: True Positives/True Positive+False Negatives

**Accuracy: True Positives+True Negatives/Total Samples

**Difference: Precision measures correctness of positive predictions; recall measures how well positives are identified.

• What is overfitting and how can it be prevented?

-**Overfitting: Model learns noise, not just patterns.

**Prevention: Use cross-validation, regularization, pruning, simpler models, more data.

• Explain the concept Of cross-validation.

-Concept: Split data into k-folds, train on k-1 folds, validate on remaining fold. Repeat k times, average results.

• What is the difference between a classification and a regression problem?

-*Classification: Predict categorical outcomes (e.g., spam/not spam).

*Regression: Predict continuous outcomes (e.g., house prices).

• Explain the concept Of ensemble learning.

=Concept: Combine multiple models to improve performance (e.g., bagging, boosting).

• What is gradient descent and how does it work?

= *Concept: Optimization algorithm to minimize loss function.

*How it Works: Update model parameters iteratively by moving in the direction of negative gradient.

• Describe the difference between batch gradient descent and stochastic gradient descent.

=*Batch: Uses all training data at once for updates.

*Stochastic: Uses one training sample per update, faster but noisier.

• What is the Curse Of dimensionality in machine learning?

=Concept: High-dimensional spaces make learning and generalizing difficult due to sparse data

• Explain the difference between Ll and L2 regularization.

-*L1 (Lasso): Adds absolute values of coefficients to loss function, can produce sparse models.

*L2 (Ridge): Adds squared values of coefficients to loss function, keeps all coefficients small.

• What is a confusion matrix and how is it used?

=Concept: Table to evaluate performance of classification models. Shows true vs predicted classes

• Define AUC-ROC curve.

=AUC: Area under the ROC curve, measures classifier performance.

ROC Curve: Plots true positive rate vs false positive rate across thresholds.

• Explain the k-nearest neighbors algorithm.

=Concept: Classify a data point based on the majority class of its k nearest neighbors.

How it Works: Calculate the distance between points, find the nearest k neighbors, and assign the majority label.

• Explain the basic concept of a Support Vector Machine (SVM).

*Concept: Find the optimal hyperplane that separates classes in a dataset.

*How it Works: Maximize the margin between the closest points (support vectors) of different classes

• How does the kernel trick work in SVM?

= Use kernel functions (e.g., linear, polynomial, RBF) to implicitly map input features

• What are the different types of kernels used in SVM and when would you use each? - *Linear: Use when data is linearly separable.

*Polynomial: Use when data has polynomial relationships.

*RBF (Gaussian): Use when data has complex boundaries.

• What is the hyperplane in SVM and how is it determined? =-Concept: The decision boundary that separates different classes.

-Determination: Found by maximizing the margin between the closest points of the classes.

• What are the pros and cons of using a Support Vector Machine (SVM)?

= -Pros: Effective in high-dimensional spaces, robust to overfitting with proper regularization.

-Cons: Computationally intensive, less effective on large datasets with noise

• Explain the difference between a hard margin and a soft margin SVM.

= *Hard Margin: No misclassifications allowed, only works with linearly separable data.

*Soft Margin: Allows some misclassifications, uses a regularization parameter to balance margin width and misclassification.

• Describe the process of constructing a decision tree.

=Process: Split data recursively based on feature values to create branches, stop when leaves are pure or other stopping criteria are met.

• Describe the working principle of a decision tree.

=Concept: Use a tree structure to make decisions based on feature values, starting from the root and moving to leaves.

• What is information gain and how is it used in decision trees?

=-Concept: Measure of how well a feature separates the classes.

-Usage: Select features with the highest information gain to split nodes.

• Explain Cini impurity and its role in decision trees.

*Concept: Measure of impurity or disorder in a dataset.

*Role: Used to select features by minimizing impurity in splits.

• What are the advantages and disadvantages of decision trees?

=*Advantages: Easy to understand, interpretable, handles both numerical and categorical data.

*Disadvantages: Prone to overfitting, sensitive to small data changes.

• How do random forests improve upon declsion trees?

= -Improvement: Combine multiple trees to reduce overfitting and improve generalization.

-How it Works: Create multiple trees using bootstrapped subsets of data and aggregate their predictions

• How does a random forest algorithm work? =1.Data Sampling: Random subsets of data created using bootstrapping.

2.Tree Construction: Multiple decision trees built with random feature subsets.

V3.oting: Trees vote on classification or average predictions for regression.

4.Final Prediction: Combines tree outputs for robust predictions.

• What is bootstrapping in the context of random forests?

=-Definition: Sampling technique with replacement to create multiple datasets.

-Purpose: Generates diverse subsets for training individual decision trees in Random Forests.

• Explain the concept of feature importance in random forests.

=Definition: Measures impact of each feature on model predictions.

Calculation: Analyzes how much each feature contributes to reducing prediction error across all trees.

• What are the key hyperparameters of a random forest and how do they affect the model?

=*Number of Trees: Increases model complexity and computational cost.

*Max Features: Controls the number of features considered for splitting.

*Tree Depth: Influences model complexity and overfitting

• Describe the logistic regression model and its assumptions.

=-Model: Linear regression for binary classification.

-Assumptions: Linear relationship between features and log-odds of the outcome.

• How does logistic regression handle binary classification problems?

=Output: Predicts probability of a binary outcome.

Decision: Classifies based on threshold (typically 0.5)

• What is the sigmoid function and how is it used in logistic regression?

=*Definition: S-shaped curve transforming input to a range between 0 and 1.

*Use: Converts logistic regression output into probabilities

• Explain the concept of the cost function in logistic regression.

=-Purpose: Measures model performance by penalizing incorrect predictions.

-Optimization: Minimizes cost using techniques like gradient descent

• How can logistic regression be extended to handle multiclass classification?

=One-vs-Rest: Trains multiple binary classifiers, one for each class.

Softmax Function: Outputs probabilities across multiple classes.

• What is the difference between Ll and L2 regularization in logistic regression?

=*L1 (Lasso): Penalizes absolute weights, promoting sparsity.

*L2 (Ridge): Penalizes squared weights, shrinking coefficients towards zero

• What is XGBoost and how does it differ from other boosting algorithms?

=*Definition: Gradient boosting library for optimized performance.

*Advantages: Handles large datasets, supports regularization, and manages missing values.

• Explain the concept of boosting in the context of ensemble learning.

=-Purpose: Combines weak learners sequentially to improve prediction accuracy.

-Process: Adjusts weights of misclassified instances to prioritize learning from errors.

• How does XGBoost handle missing values?

*Treatment: Automatically handles missing values during training.

*Process: Learns default directions for missing data, reducing prediction bias.

• What are the key hyperparameters in XGBoost and how do they affect model performance?

=1.Number of Trees: Controls the number of boosting rounds.

2.Learning Rate (eta): Scales the contribution of each tree.

3.Tree Depth (max_depth): Limits the depth of each tree.

4.Subsample: Fraction of training data used per tree.

5.Column Subsampling (colsample_bytree): Fraction of features used per tree.

• Describe the process of gradient boosting in XGBoost.

=Initialization: Starts with a simple model (usually a single leaf).

Iterative Improvement: Sequentially adds new models to correct errors made by existing models.

Gradient Descent: Optimizes a loss function by minimizing errors in predictions.

• What are the advantages and disadvantages of using XGBoost? = Advantage

*High Performance: Fast execution speed and scalability.

*Regularization: Reduces overfitting with regularization techniques.

Disadvantage *Complexity: Requires careful tuning of hyperparameters.

*Computationally Intensive: Can be resource-intensive, especially with large datasets
Q1.1: Write the Answer to these questions.

• What is the difference between static and dynamic variables in python?

ans) Static Variables Definition: Static variables, also known as class variables, are variables that are shared among all instances of a class.

1.Scope: They are defined within a class but outside any instance methods.

Dynamic Variables Definition: Dynamic variables, often referred to as instance variables, are unique to each instance of a class.

1.Scope: They are defined within methods, usually the' init' method, and are prefixed with 'self' to indicate they belong to the instance.

• Explain the purpose of "pop","popitem", and "clear()" in a dictionary with suitable examples.

pop Method Purpose: The pop method removes the specified key and returns the corresponding value. If the key is not found, it raises a KeyError, unless a default value is provided. ex:

print(my_dict.pop('b'))  # Output: 2
print(my_dict)  # Output: {'a': 1, 'c': 3}

print(my_dict.pop('d', 'Not Found'))  # Output: Not Found
print(my_dict)  # Output: {'a': 1, 'c': 3}
popitem Method Purpose: The popitem method removes and returns the last key-value pair as a tuple. If the dictionary is empty, it raises a KeyError.

print(my_dict.popitem())  # Output: ('c', 3)
print(my_dict)  # Output: {'a': 1, 'b': 2}
clear Method Purpose: The clear method removes all items from the dictionary, leaving it empty.

https://colab.research.google.com/drive/1hjgOanZBKDzd2bZ6wRMluW1u3AfxvCNn#scrollTo=-lPY-epTr3U9&line=1&uniqifier=1
(If you get any issue with reading it visit google colab using above link)
my_dict.clear()
print(my_dict)  # Output: {}
• What do you mean by FrozenSet? Explain it with suitable examples.

A frozenset in Python is an immutable set, meaning its elements cannot be modified after creation. It can be used as dictionary keys or set elements because it is hashable.

fs = frozenset([1, 2, 3])
print(fs)  # Output: frozenset({1, 2, 3})

my_dict = {fs: "Group 1"}
print(my_dict[fs])  # Output: Group 1
• Differentiate between mutable and immutable data types in python and give examples of mutable and immutable data types.

Mutable Data Types: List: lst = [1, 2, 3] Dictionary: dct = {'a': 1, 'b': 2} Set: st = {1, 2, 3} Immutable Data Types: string: s = "hello" Tuple: tpl = (1, 2, 3) Frozenset: fs = frozenset([1, 2, 3])

lst = [1, 2, 3]
lst.append(4)
print(lst)  # Output: [1, 2, 3, 4]

# Immutable
s = "hello"
# s[0] = 'H'  # This will raise an error
• What is init ? explain with an example.

init is a special method in Python classes, called a constructor, which is automatically invoked when a new instance of the class is created. It initializes the instance's attributes

    def __init__(self, name, age):
        self.name = name
        self.age = age

p1 = Person("Alice", 30)
print(p1.name)  # Output: Alice
print(p1.age)   # Output: 30
• What is docstring in Python?Explain with an example.

A docstring in Python is a string literal that appears right after the definition of a function, method, class, or module. It is used to document the purpose and behavior of the component.

    """This function greets the person whose name is passed as an argument."""
    return f"Hello, {name}!"

print(greet.__doc__)  # Output: This function greets the person whose name is passed as an argument.
• What are unit tests in Python?

Unit tests in Python are a way to test small parts of your code to make sure they work correctly. They help you catch bugs early and ensure that changes to your code don't break existing functionality. Here's a simple example using the unittest module:


def add(a, b):
    return a + b

class TestAddFunction(unittest.TestCase):
    def test_add(self):
        self.assertEqual(add(2, 3), 5)  # Check if add(2, 3) returns 5
        self.assertEqual(add(-1, 1), 0)  # Check if add(-1, 1) returns 0

if __name__ == '__main__':
    unittest.main()
• What is break, continue and pass in python? break Purpose: Terminates the nearest enclosing loop (for loop, while loop, or nested loops).

for i in range(5):
    if i == 3:
        break
    print(i)
# Output: 0, 1, 2
continue Purpose: Skips the current iteration of a loop and proceeds to the next iteration.

    if i == 2:
        continue
    print(i)
# Output: 0, 1, 3, 4
pass Purpose: Does nothing and acts as a placeholder where syntactically required.

    if i == 2:
        pass  # Placeholder, does nothing
    print(i)
# Output: 0, 1, 2, 3, 4
• What is the use of self in Python?

self is used inside class methods to refer to the instance (object) itself. It allows methods to access and modify instance attributes.

class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age

    def greet(self):
        return f"Hello, my name is {self.name} and I am {self.age} years old."

# Creating an instance of Person
p = Person("Alice", 30)
print(p.greet())  # Output: Hello, my name is Alice and I am 30 years old.
• What are globa , protected and private attributes in Python?

Global Attributes: Variables defined at the module level, accessible throughout the module.


def some_function():
    print(global_var)

some_function()  # Output: 10
Protected Attributes: Conventionally marked with a single leading underscore (_). It suggests that the attribute should be used within its class or module.

class MyClass:
    def __init__(self):
        self._protected_var = 20

    def get_protected_var(self):
        return self._protected_var

obj = MyClass()
print(obj.get_protected_var())  # Output: 20
Private Attributes: Indicated by a double leading underscore (__). It triggers name mangling to make the attribute less accessible from outside the class.

    def __init__(self):
        self.__private_var = 30

    def get_private_var(self):
        return self.__private_var

obj = MyClass()
# Directly accessing __private_var will raise an AttributeError
print(obj.get_private_var())  # Output: 30
• What are modules and packages in python?

Modules: Modules in Python are files containing Python code that define functions, classes, and variables. They help organize code into reusable units, making it easier to manage and maintain.

# math_operations.py
def add(a, b):
    return a + b

# main.py
import math_operations

print(math_operations.add(5, 3))  # Output: 8
Packages: Packages are directories containing multiple Python modules along with a special init.py file. They provide a way to structure and namespace Python's module namespace, allowing for hierarchical organization of code.

# my_package/module1.py
def func1():
    print("Function 1")

# my_package/module2.py
def func2():
    print("Function 2")

# main.py
from my_package import module1, module2

module1.func1()  # Output: Function 1
module2.func2()  # Output: Function 2
• What are lists and tuples? What is the key difference between the two?

Lists: Mutable sequences of elements, defined with square brackets [ ].

Tuples: Immutable sequences of elements, defined with parentheses ( ).

my_list = [1, 2, 3]

# Tuple example
my_tuple = (1, 2, 3)
• What is an Interpreted language & dynamically typed language?Write 5 differences between them.

Interpreted vs Dynamically Typed Language:

Interpreted Language: Code is executed line by line without compiling (e.g., Python). Dynamically Typed Language: Variable types are determined at runtime, allowing flexibility but potentially leading to runtime errors.

x = 5  # Integer
x = "hello"  # String
• What are Dict and List comprehensions?

Dict and List Comprehensions:

List Comprehension: Concise way to create lists based on existing lists. Dict Comprehension: Similar to list comprehension but creates dictionaries

squares = [x**2 for x in range(5)]

# Dict comprehension
square_dict = {x: x**2 for x in range(5)}
• What are decorators in Python? Explain it with an example.Write down its use cases.

Decorators:

Functions that modify the behavior of other functions or methods without changing their code. Used for adding functionalities like logging, timing, or access control.

    def wrapper():
        print("Something is happening before the function is called.")
        func()
        print("Something is happening after the function is called.")
    return wrapper

@my_decorator
def say_hello():
    print("Hello!")

say_hello()
• How is memory managed in Python?

Memory Management in Python:

Handled automatically by Python's memory manager using techniques like reference counting and garbage collection. Ensures efficient allocation and deallocation of memory.

• What is lambda in python? Why is it used?

Lambda Functions:

Small anonymous functions defined with lambda keyword. Used for short functions where def syntax is overly verbose

add = lambda x, y: x + y
print(add(3, 5))  # Output: 8
• Explain split() and join() functions in Python?

split(): Splits a string into a list of substrings based on a delimiter.

join(): Concatenates elements of an iterable into a string, with a specified separator.

sentence = "Hello, world!"
words = sentence.split(", ")  # Output: ['Hello', 'world!']
new_sentence = "-".join(words)  # Output: 'Hello-world!'
• What are iterators , iterable & generators in Python?

Iterable: Any object capable of returning its members one at a time (e.g., lists, tuples).

Iterator: Object used to iterate through an iterable using iter() and next() methods.

Generators: Functions that generate a sequence of values lazily, using yield instead of return.

def square_numbers(n):
    for i in range(n):
        yield i ** 2

my_gen = square_numbers(5)
print(list(my_gen))  # Output: [0, 1, 4, 9, 16]
• What is the difference between xrange and range in python?

range: Returns a list of numbers and stores them in memory.

xrange: Generates numbers on-the-fly, using less memory, but available only in Python 2 (in Python 3, range behaves like xrange).

for i in xrange(5):
    print(i)
• Pillars of Oops.

Pillars of OOPs:

Encapsulation: Bundling of data and methods that operate on the data.

Inheritance: Ability of a class to inherit properties and methods from another class.

Polymorphism: Ability to use a single interface for different data types or classes.

Abstraction: Hiding complex implementation details and showing only relevant information.

• How will you check if a class is a child Of another class?

Use issubclass() function to check if a class is a subclass of another class.

    pass

class Child(Parent):
    pass

print(issubclass(Child, Parent))  # Output: True
• How does inheritance work in python? Explain all types of inheritance with an example.

Inheritance in Python:

Mechanism where a new class derives attributes and methods from an existing class.

Types include single, multiple, multilevel, and hierarchical inheritance.

class Parent:
    def show(self):
        print("Parent method")

class Child(Parent):
    pass

obj = Child()
obj.show()  # Output: Parent method
• What is encapsulation? Explain it with an example.

Encapsulation is the bundling of data and methods that operate on the data into a single unit (class). Ex:

    def __init__(self, brand):
        self.brand = brand
        self.__mileage = 0  # Private attribute

    def drive(self):
        self.__mileage += 10

my_car = Car("Toyota")
my_car.drive()
# Accessing private attribute directly will raise an AttributeError
• What is polymorphism? Explain it with an example.

Polymorphism allows methods to be written in a way that they can take multiple forms or implementations. Ex:

    def sound(self):
        print("Bark")

class Cat:
    def sound(self):
        print("Meow")

def make_sound(animal):
    animal.sound()

make_sound(Dog())  # Output: Bark
make_sound(Cat())  # Output: Meow
Q1.2. Which of the following identifier names are invalid and why? Serial_no. 1st_Room Hundred$ Total_Marks total-Marks Total Marks True _ percentag

1.serial_no. -- it's valid identifier

2.1st_room -- it's invalid identifier due to having number at the begining.

3.Hundred$ - it's valid identifier

4.Total_Marks -- it's valid identifier

5.total-marks -- it's invalid identifier due to hyphens (-) are not allowed

6.Total Marks -- it's invalid identifier due to space are not allowed

7.True -- it's invalid identifier due to Keywords are not allowed

8._percentag - it's valid identifier

Question 1.3. name = ('Mohan•, "dash", "karam•, do the following operations in this list; a) add an element "freedom_fighter" in this list at the 0th index.

name_list = list(name)
name_list.insert(0, "freedom_fighter")
name = tuple(name_list)

print(name)  # Output: ('freedom_fighter', 'Mohan', 'dash', 'karam')
b) find the output of the following rand explain how?

name = ["freedeomFighter","Bapuji","MOhan","dash", "karam","chandra","gandhi"] length1 = len((name[-len(name)+1:-1:2])) length2 = len((name[-len(name)+1:-1])) print(length1+length2)

name = ["freedeomFighter", "Bapuji", "MOhan", "dash", "karam", "chandra", "gandhi"]
length1 = len(name[1:-1:2])
length2 = len(name[1:-1])
print(length1 + length2)  # Output: 8
The code calculates lengths of two slices of the list and sums them.

length1 is 3 and length2 is 5. The sum is 8.

c) Add Two more elements in the name ["Netaji","Bose"] at the end of the list

name = ["freedeomFighter", "Bapuji", "MOhan", "dash", "karam", "chandra", "gandhi"]
name.extend(["Netaji", "Bose"])
print(name)
d) What will be the value of temp: name = ["Bapuji","dash","karam","chandra","gandhi","mohan"] temp = name[-1] name[-1] =name[0] name[0] = temp print(name)

ans) (outpur) name = ['mohan', 'dash', 'karam', 'chandra', 'gandhi', 'Bapuji']

Question 1.4.Find the output of the following.

animal = ["Human","cat","mat","cat","rat","Human"] print(animal.count('Human')) print(animal.index('rat')) print(len(animal))

print(animal.count('Human')) #output 2
print(animal.index('rat')) #output 4
print(len(animal)) #output 6
Q1.5) tuple1 = (10,20,"apple",3.4,"a",["master","ji"],("sita","geeta",22),[{"roll_no":1},{"name":"Navneet"}])

a)print(len(tuple1)) b)print(tuple1[-1][-1]["name"]) c)fetch the value of rool_no from this tuple. d)print(tuple1[-3][1]) e)fetch the element "22" from this tuple.


# a) Print length of the tuple
print(len(tuple1))  # Output: 8

# b) Print the value associated with the key "name"
print(tuple1[-1][-1]["name"])  # Output: Navneet

# c) Fetch the value of "roll_no"
print(tuple1[-1][0]["roll_no"])  # Output: 1

# d) Print the second element of the seventh item in the tuple
print(tuple1[-3][1])  # Output: geeta

# e) Fetch the element "22" from the tuple
print(tuple1[-3][-1])  # Output: 22
1.6. Write a program to display the appropriate message as per the color Of signal(RED-Stop/YeIIow-Stay/Green-Go) at the road crossing.

signal = input("Enter the signal color (RED/Yellow/Green): ").strip().lower()

if signal == 'red':
    print("Stop")
elif signal == 'yellow':
    print("Stay")
elif signal == 'green':
    print("Go")
else:
    print("Invalid color")
1.7. Write a program to create a simple calculator performing only four basic perations(+,-,/,* ).

def calculator(a, b, operation):
    if operation == '+':
        return a + b
    elif operation == '-':
        return a - b
    elif operation == '*':
        return a * b
    elif operation == '/':
        return a / b
    else:
        return "Invalid operation"

a = float(input("Enter first number: "))
b = float(input("Enter second number: "))
operation = input("Enter operation (+, -, *, /): ")

result = calculator(a, b, operation)
print("The result is:", result)
1.8. Write a program to find the larger of the three pre- specified numbers using temary operators.

a, b, c = 5, 10, 3
largest = a if a > b and a > c else b if b > c else c
print("The largest number is:", largest)
1.9. Write a program to find the factors Of a whole number using a while loop.

number = int(input("Enter a whole number: "))
i = 1

while i <= number:
    if number % i == 0:
        print(i)
    i += 1
1.10. Write a program to find the sum of all the positive numbers entered by the user. As soon as the user enters a negative number, stop taking in any further input from the user and display the sum .

total = 0

while True:
    num = int(input("Enter a number: "))
    if num < 0:
        break
    total += num

print("The sum is:", total)
1.11. Write a program to find prime numbers between 2 to 100 using nested for loops.

for num in range(2, 101):
    is_prime = True
    for i in range(2, int(num ** 0.5) + 1):
        if num % i == 0:
            is_prime = False
            break
    if is_prime:
        print(num)
1.12. Write the programs for the following: Screenshot 2024-07-13 141144.png

(if image not visible)

Criteria Grade
percentage > 85 A

percentage < 85 && percentage >= 75 B

percentage < 75 && percentage >= 50 c

percentage > 30 && percentage 50 D

percentage `<30 Reappear

Q)Accept and Display Marks of Five Subjects

a)Allows the user to input marks for five subjects and stores them in a list marks, then prints the list.

# Accept marks of five subjects from the user
marks = []
for i in range(5):
    subject_marks = float(input(f"Enter marks for subject {i+1}: "))
    marks.append(subject_marks)

# Display the marks of all subjects
print("Marks obtained in five subjects:", marks)
Q)Calculate Sum and Percentage of Marks

a) Calculates the total marks and percentage based on the marks entered. It divides the total marks by 5 to get the average and then calculates the percentage, finally printing both.

# Calculate sum of marks
total_marks = sum(marks)

# Calculate percentage
percentage = (total_marks / (5 * 100)) * 100

# Display the sum and percentage
print(f"Total marks obtained: {total_marks}")
print(f"Percentage: {percentage}%")
Q)Find Grade Based on Percentage Using if-elif Statements

a)Determines the grade based on the calculated percentage using if-elif statements. It checks the percentage against predefined ranges and assigns a grade accordingly, then displays the grade.

# Determine grade based on percentage using if-elif statements
if percentage > 85:
    grade = "A"
elif percentage >= 75:
    grade = "B"
elif percentage >= 50:
    grade = "C"
elif percentage >= 30:
    grade = "D"
else:
    grade = "Reappear"

# Display the grade
print(f"Grade: {grade}")
1.13. Write a program for VIBGYOR Spectrum based on their Wavelength using. Wavelength Range:

Color Wavelength Range (nanometers)
Violet 400 - 440

Indigo 440 - 460

Blue 460 - 500

Green 500 - 570

Yellow 570 - 590

Orange 590 - 620

Red 620 - 720

wavelength = float(input("Enter the wavelength in nanometers: "))

# Determine and print the corresponding color
if 400 <= wavelength < 440:
    print("The color is Violet")
elif 440 <= wavelength < 460:
    print("The color is Indigo")
elif 460 <= wavelength < 500:
    print("The color is Blue")
elif 500 <= wavelength < 570:
    print("The color is Green")
elif 570 <= wavelength < 590:
    print("The color is Yellow")
elif 590 <= wavelength < 620:
    print("The color is Orange")
elif 620 <= wavelength <= 720:
    print("The color is Red")
else:
    print("Wavelength is outside the visible spectrum")
1.14.Consider the gravitational interactions between the Earth, Moon, and Sun in Our solar system.

Given: mass _earth = 5.972e24 # Mass of Earth in kilograms

mass _moon = 7.34767309e22 # Mass of Moon in kilograms

mass_sun=1.989e30 # Mass of Sun in kilograms

distance_earth _sun 1.496e11 # Average distance between Earth and Sun in meters

distance_ moon_earth 3.844e8 # Average distance between Moon and Earth in meters Tasks:

• Calculate the gravitational force between the Earth and the Sun.

# Constants
G = 6.67430e-11  # Gravitational constant in m^3 kg^-1 s^-2

# Given masses and distance
mass_earth = 5.972e24  # Mass of Earth in kilograms
mass_sun = 1.989e30  # Mass of Sun in kilograms
distance_earth_sun = 1.496e11  # Average distance between Earth and Sun in meters

# Calculate gravitational force between Earth and Sun
force_earth_sun = G * (mass_earth * mass_sun) / (distance_earth_sun ** 2)

print(f"The gravitational force between Earth and Sun is {force_earth_sun:.2e} Newtons")
Calculate the Gravitational Force between Moon and Earth

# Given mass and distance
mass_moon = 7.34767309e22  # Mass of Moon in kilograms
distance_moon_earth = 3.844e8  # Average distance between Moon and Earth in meters

# Calculate gravitational force between Moon and Earth
force_moon_earth = G * (mass_moon * mass_earth) / (distance_moon_earth ** 2)

print(f"The gravitational force between Moon and Earth is {force_moon_earth:.2e} Newtons")
Compare the Gravitational Forces

# Compare the gravitational forces
if force_earth_sun > force_moon_earth:
    stronger_force = "Earth and Sun"
else:
    stronger_force = "Moon and Earth"

print(f"The stronger gravitational force is between {stronger_force}")
• Explain which celestial body (Earth or Moon) is more attracted to the other based on the comparison.

1.The gravitational force between the Earth and the Sun is much stronger than the gravitational force between the Moon and the Earth.

2.This means that Earth is more attracted to the Sun than to the Moon.

3.Despite the Moon being much closer to Earth than the Sun, the Sun's significantly larger mass results in a much stronger gravitational pull on Earth compared to the Moon.

Q2. Design and implement a python program for managing student information using object—oriented principles. Create a class called -student- with encapsulated attributes for name, age, and roll number. Implement getter and setter methods for these attributes. Additionally, provide methods to display student information and update student details.

Tasks:

• Define the •Student' class with encapsulated attributes. class Student:

    def __init__(self, name, age, roll_number):
        self.__name = name
        self.__age = age
        self.__roll_number = roll_number

    # Getter methods
    def get_name(self):
        return self.__name

    def get_age(self):
        return self.__age

    def get_roll_number(self):
        return self.__roll_number

    # Setter methods
    def set_name(self, name):
        self.__name = name

    def set_age(self, age):
        self.__age = age

    def set_roll_number(self, roll_number):
        self.__roll_number = roll_number
Implement Getter and Setter Methods for the Attributes

    # Method to display student information
    def display_info(self):
        print(f"Name: {self.__name}, Age: {self.__age}, Roll Number: {self.__roll_number}")

    # Method to update student details
    def update_details(self, name=None, age=None, roll_number=None):
        if name:
            self.__name = name
        if age:
            self.__age = age
        if roll_number:
            self.__roll_number = roll_number
Create Instances Of the Student Class and Test the Implemented Functionality

# Create instances of Student class
student1 = Student("John Doe", 18, "S123")
student2 = Student("Jane Smith", 20, "S456")

# Display initial information
student1.display_info()
student2.display_info()

# Update student1's details
student1.set_age(19)
student1.update_details(name="Johnathan Doe")

# Display updated information
student1.display_info()
Q3.Develop a python program for managing library resources efficiently. Design a class named -LibraryB00kwith attributes like book name, author, and availability Status. Implement methods for borrowing and returning books while ensuring proper encapsulation Of attributes.

Tasks:

• Create the -LibraryBook' class with encapsulated attributes.

class LibraryBook:
    def __init__(self, book_name, author, availability=True):
        self.__book_name = book_name
        self.__author = author
        self.__availability = availability
Implement Methods for Borrowing and Returning Books

    def borrow_book(self):
        if self.__availability:
            self.__availability = False
            print(f"Borrowed: {self.__book_name}")
        else:
            print(f"Sorry, {self.__book_name} is not available.")

    def return_book(self):
        if not self.__availability:
            self.__availability = True
            print(f"Returned: {self.__book_name}")
        else:
            print(f"{self.__book_name} was not borrowed.")
Ensure Proper Encapsulation to Protect Book Details

    def get_details(self):
        return f"Book: {self__book_name}, Author: {self.__author}, Available: {self.__availability}"
Test the Borrowing and Returning Functionality with Sample Data

book1 = LibraryBook("Python Programming", "John Doe")
book2 = LibraryBook("Data Structures", "Jane Smith", False)

# Test borrowing and returning
print(book1.get_details())
book1.borrow_book()
print(book1.get_details())
book1.return_book()
print(book1.get_details())

print(book2.get_details())
book2.borrow_book()
book2.return_book()
Q4.Create a simple banking System using Object-oriented concepts in python. Design classes representing different types Of bank accounts such as savings and checking. Implement methods for deposit, withdraw, and balance inquiry. Utilize inheritance to manage different account types efficiently.

Tasks:

• 1. Define base class(es) for bank accounts with common attributes and methods.

class BankAccount:
    def __init__(self, account_holder, balance=0):
        self.account_holder = account_holder
        self.balance = balance

    def deposit(self, amount):
        self.balance += amount
        print(f"Deposited {amount}. New balance: {self.balance}")

    def withdraw(self, amount):
        if amount > self.balance:
            print("Insufficient funds.")
        else:
            self.balance -= amount
            print(f"Withdrew {amount}. New balance: {self.balance}")

    def get_balance(self):
        return self.balance
Implement Subclasses for Specific Account Types
class SavingsAccount(BankAccount):
 def __init__(self, account_holder, balance=0):
     super().__init__(account_holder, balance)
class CheckingAccount(BankAccount):
 def __init__(self, account_holder, balance=0):
     super().__init__(account_holder, balance)
Provide Methods for Deposit, Withdraw, and Balance Inquiry in Each Subclass
a3)Methods are inherited from the base class, so no need to redefine them.

Test the Banking System by Creating Instances of Different Account Types and Performing Transactions
savings = SavingsAccount("Alice", 1000)
checking = CheckingAccount("Bob", 500)

# Test deposit, withdraw, and balance inquiry
savings.deposit(500)
savings.withdraw(200)
print(f"Savings Account Balance: {savings.get_balance()}")

checking.deposit(300)
checking.withdraw(800)
print(f"Checking Account Balance: {checking.get_balance()}")
Q5)Write a python program that models different animals and their sounds. Design a base class called •Animal* with a method Create subclasses like 'Dog' and 'Cat' that override the method to produce appropriate sounds.

Tasks:

•1. Define the Animal Class with a Method make_sound

class Animal:
    def make_sound(self):
        pass
Create Subclasses Dog and Cat that Override the make_sound Method

class Dog(Animal):
 def make_sound(self):
     return "Woof!"
class Cat(Animal):
 def make_sound(self):
     return "Meow!"
Implement the Sound Generation Logic for Each Subclass

A)Sound logic is implemented in the overridden make_sound methods of the subclasses.

Test the Program by Creating Instances of Dog and Cat and Calling the make_sound Method
# Create instances of Dog and Cat
dog = Dog()
cat = Cat()
# Call the make_sound method
print(dog.make_sound())  # Outputs: Woof!
print(cat.make_sound())  # Outputs: Meow!
Q6.Write a code for Restaurant Management System Using OOPS:

• Create a Menultem class that has attributes such as name, description, price, and category.

class MenuItem:
    def __init__(self, name, description, price, category):
        self.__id = id(self)
        self.name = name
        self.description = description
        self.price = price
        self.category = category
    def get_id(self):
        return self.__id
Implement Methods to Add, Update, and Remove Menu Items

class Menu:
    def __init__(self):
        self.items = []

    def add_item(self, item):
        self.items.append(item)

    def update_item(self, item_id, name=None, description=None, price=None, category=None):
        for item in self.items:
            if item.get_id() == item_id:
                if name: item.name = name
                if description: item.description = description
                if price: item.price = price
                if category: item.category = category
                break

    def remove_item(self, item_id):
        self.items = [item for item in self.items if item.get_id() != item_id]
Q)Use Encapsulation to Hide the Menu Item's Unique ID

A)The unique ID is hidden within the MenuItem class and accessed via the get_id method.

Q)Inherit from the MenuItem Class to Create FoodItem and BeverageItem Classes

class FoodItem(MenuItem):
    def __init__(self, name, description, price, category, cuisine_type):
        super().__init__(name, description, price, category)
        self.cuisine_type = cuisine_type

class BeverageItem(MenuItem):
    def __init__(self, name, description, price, category, size):
        super().__init__(name, description, price, category)
        self.size = size


# test and implimentations
# Create Menu
menu = Menu()

# Add Items
food = FoodItem("Burger", "Cheeseburger", 5.99, "Food", "American")
beverage = BeverageItem("Coke", "Coca-Cola", 1.99, "Beverage", "500ml")
menu.add_item(food)
menu.add_item(beverage)

# Update Item
menu.update_item(food.get_id(), price=6.99)

# Remove Item
menu.remove_item(beverage.get_id())

# Display Menu
for item in menu.items:
    print(f"{item.name}: ${item.price}")
7.Write a code for Hotel Management System using OOPS :

• Create a Room class that has attributes such as room number, room type, rate, and availability (private).

class Room:
    def __init__(self, room_number, room_type, rate):
        self.__id = id(self)
        self.room_number = room_number
        self.room_type = room_type
        self.rate = rate
        self.__availability = True

    def get_id(self):
        return self.__id

    def is_available(self):
        return self.__availability

    def book_room(self):
        if self.__availability:
            self.__availability = False
            return True
        return False

    def check_in(self):
        if not self.__availability:
            self.__availability = True
            return True
        return False

    def check_out(self):
        self.__availability = True
• Inherit from the Room class to create a SuiteRoom class and a StandardRoom class, each with their own specific attributes and methods.

class SuiteRoom(Room):
    def __init__(self, room_number, rate, amenities):
        super().__init__(room_number, "Suite", rate)
        self.amenities = amenities

class StandardRoom(Room):
    def __init__(self, room_number, rate):
        super().__init__(room_number, "Standard", rate)
• Implement methods to book a room, check in a guest, and check out a guest

a)Methods are already implemented in the Room class: book_room, check_in, and check_out

8.Write a code for Fitness Club Management System using OOPS:

• Create a Member class that has attributes such as name, age, membership type, and membership status (private).

class Member:
    def __init__(self, name, age, membership_type):
        self.__id = id(self)
        self.name = name
        self.age = age
        self.membership_type = membership_type
        self.__status = "Active"

    def get_id(self):
        return self.__id

    def get_status(self):
        return self.__status

    def register(self):
        self.__status = "Active"

    def renew_membership(self):
        self.__status = "Renewed"

    def cancel_membership(self):
        self.__status = "Cancelled"
Inherit from the Member Class to Create FamilyMember and IndividualMember Classes

class FamilyMember(Member):
    def __init__(self, name, age, membership_type, family_size):
        super().__init__(name, age, membership_type)
        self.family_size = family_size

class IndividualMember(Member):
    def __init__(self, name, age, membership_type):
        super().__init__(name, age, membership_type)
q)Implement Methods to Register, Renew, and Cancel Membership

a)Methods register, renew_membership, and cancel_membership are already implemented in the Member class

# Test the Implementation
# Create Members
family_member = FamilyMember("John Doe", 40, "Family", 4)
individual_member = IndividualMember("Jane Smith", 30, "Individual")

# Register Members
family_member.register()
individual_member.register()

# Renew Membership
family_member.renew_membership()

# Cancel Membership
individual_member.cancel_membership()

# Check Membership Status
print(family_member.get_status())  # Renewed
print(individual_member.get_status())  # Cancelled
Q9.Write a code for Event Management System using OOPS:

• Create an Event class that has attributes such as name, date, time, location, and list of attendees (private).

class Event:
    def __init__(self, name, date, time, location):
        self.__id = id(self)
        self.name = name
        self.date = date
        self.time = time
        self.location = location
        self.__attendees = []

    def get_id(self):
        return self.__id

    def add_attendee(self, attendee):
        self.__attendees.append(attendee)

    def remove_attendee(self, attendee):
        self.__attendees.remove(attendee)

    def get_total_attendees(self):
        return len(self.__attendees)
Inherit from the Event Class to Create PrivateEvent and PublicEvent Classes

class PrivateEvent(Event):
    def __init__(self, name, date, time, location, invite_only):
        super().__init__(name, date, time, location)
        self.invite_only = invite_only

class PublicEvent(Event):
    def __init__(self, name, date, time, location, max_capacity):
        super().__init__(name, date, time, location)
        self.max_capacity = max_capacity
Q)Implement Methods to Create, Add/Remove Attendees, and Get Total Number of Attendees

A)Methods add_attendee, remove_attendee, and get_total_attendees are already implemented in the Event class.

# Test and implementation

# Create Events
private_event = PrivateEvent("Birthday Party", "2024-08-20", "18:00", "John's House", True)
public_event = PublicEvent("Concert", "2024-09-15", "20:00", "Central Park", 500)

# Add Attendees
private_event.add_attendee("Alice")
private_event.add_attendee("Bob")
public_event.add_attendee("Charlie")

# Remove Attendee
private_event.remove_attendee("Bob")

# Get Total Attendees
print(private_event.get_total_attendees())  # 1
print(public_event.get_total_attendees())  # 1
Q10.Write a code for Airline Reservation System using OOPS:

• Create a Flight class that has attributes such as flight number, departure and arrival airports, departure and arrival times, and available seats (private).

class Flight:
    def __init__(self, flight_number, departure_airport, arrival_airport, departure_time, arrival_time, total_seats):
        self.__id = id(self)
        self.flight_number = flight_number
        self.departure_airport = departure_airport
        self.arrival_airport = arrival_airport
        self.departure_time = departure_time
        self.arrival_time = arrival_time
        self.__available_seats = total_seats

    def get_id(self):
        return self.__id

    def book_seat(self):
        if self.__available_seats > 0:
            self.__available_seats -= 1
            return True
        else:
            return False

    def cancel_reservation(self):
        if self.__available_seats < total_seats:
            self.__available_seats += 1
            return True
        else:
            return False

    def get_available_seats(self):
        return self.__available_seats
Inherit from the Flight Class to Create DomesticFlight and InternationalFlight Classes

class DomesticFlight(Flight):
    def __init__(self, flight_number, departure_airport, arrival_airport, departure_time, arrival_time, total_seats, baggage_allowance):
        super().__init__(flight_number, departure_airport, arrival_airport, departure_time, arrival_time, total_seats)
        self.baggage_allowance = baggage_allowance

class InternationalFlight(Flight):
    def __init__(self, flight_number, departure_airport, arrival_airport, departure_time, arrival_time, total_seats, meal_service):
        super().__init__(flight_number, departure_airport, arrival_airport, departure_time, arrival_time, total_seats)
        self.meal_service = meal_service
q)Implement Methods to Book a Seat, Cancel a Reservation, and Get Remaining Available Seats

a)Methods book_seat, cancel_reservation, and get_available_seats are already implemented in the Flight class.

# test and implementation
# Create Flights
domestic_flight = DomesticFlight("DF101", "JFK", "LAX", "10:00", "14:00", 150, "20 kg")
international_flight = InternationalFlight("IF202", "LHR", "JFK", "08:00", "16:00", 200, "Standard Meal")

# Book Seats
print(domestic_flight.book_seat())  # True (Seat booked)
print(international_flight.book_seat())  # True (Seat booked)

# Cancel Reservation
print(domestic_flight.cancel_reservation())  # True (Reservation cancelled)

# Get Available Seats
print(domestic_flight.get_available_seats())  # 149
print(international_flight.get_available_seats())  # 199
Q)11. Define a python module named constants.py containing constants like pi and the speed Of light.

# constants.py
PI = 3.14159
SPEED_OF_LIGHT = 299792458  # meters per second
q12. Write a python module named calculator.py containing functions for addition, subtraction, multiplication, and division.

# calculator.py
def add(a, b):
    return a + b

def subtract(a, b):
    return a - b

def multiply(a, b):
    return a * b

def divide(a, b):
    if b != 0:
        return a / b
    else:
        return "Error: Division by zero"
q13. Implement a Python package structure for a project named ecommerce, containing modules for product management and order processing.

ecommerce/
    __init__.py
    product_management.py
    order_processing.py
q14. Implement a python module named string_utils.py containing functions for string manipulation, such as reversing and capitalizing strings.

# string_utils.py
def reverse_string(s):
    return s[::-1]

def capitalize_string(s):
    return s.capitalize()
q15) Write a Python module named file_operations.py with functions for reading, writing, and appending data to a file.

# file_operations.py
def read_file(filename):
    with open(filename, 'r') as file:
        return file.read()

def write_to_file(filename, data):
    with open(filename, 'w') as file:
        file.write(data)

def append_to_file(filename, data):
    with open(filename, 'a') as file:
        file.write(data + '\n')
q16. Write a python program to create a text file named "employees.txt" and write the details Of employees, including their name, age, and salary, into the file.

# Creating employees.txt
with open("employees.txt", 'w') as file:
    file.write("Name: John Doe\nAge: 30\nSalary: $50000\n")
    file.write("Name: Jane Smith\nAge: 25\nSalary: $45000\n")
q17. Develop a python script that opens an existing text file named "inventory.txt" in read mode and displays the contents Of the file line by line.

# Reading inventory.txt
with open("inventory.txt", 'r') as file:
    for line in file:
        print(line.strip())
q18. Create a python script that reads a text file named "expenses.txt" and calculates the total amount spent on various expenses listed in the file.

# Calculating total expenses from expenses.txt
total_expenses = 0
with open("expenses.txt", 'r') as file:
    for line in file:
        try:
            expense = float(line.strip().split()[1])  # Assuming format is 'Expense: amount'
            total_expenses += expense
        except ValueError:
            pass  # Ignore lines that don't match expected format

print(f"Total expenses: ${total_expenses}")
q19. Create a python program that reads a text file named "paragraph.txt" and counts the occurrences Of each word in the paragraph, displaying the results in alphabetical order.

# Counting word occurrences in paragraph.txt
from collections import defaultdict

word_counts = defaultdict(int)
with open("paragraph.txt", 'r') as file:
    for line in file:
        words = line.strip().split()
        for word in words:
            word_counts[word.lower()] += 1

# Display results in alphabetical order
for word in sorted(word_counts):
    print(f"{word}: {word_counts[word]}")
q20. What do you mean by Measure of Central Tendency and Measures of Dispersion. How it can be calculated. a)Measure of Central Tendency:

Mean: Sum of values divided by the number of values. Median: Middle value when values are sorted. Mode: Most frequently occurring value. Measures of Dispersion:

Range: Difference between the maximum and minimum values. Variance: Average of squared differences from the mean. Standard Deviation: Square root of variance.

q21. What do you mean by skewness. Explain its types and use graph to show.

a)Skewness:

Measures asymmetry in data distribution. Positive skew: Tail on the right side of the distribution.

Negative skew: Tail on the left side of the distribution.

Graphically, positive skew means the mean > median > mode, and negative skew means the mode > median > mean.

q22. Explain PROBABILITY MASS FUNCTION (PMF) and PROBABILITY DENSITY FUNCTION (PDF), and what is the difference between them?

a)PMF: Probability distribution of discrete random variables.

PDF: Probability distribution of continuous random variables.

PMF gives probabilities for discrete outcomes, while PDF gives probabilities for continuous outcomes. PDF is also the derivative of the cumulative distribution function (CDF).

q23. What is correlation. Explain its types in detail and what are the methods of determining correlation.

Correlation:

Measures strength and direction of relationship between two variables.

Types: Pearson correlation (linear relationship), Spearman correlation (monotonic relationship), Kendall correlation (ordinal variables).

Methods: Calculate correlation coefficient (ranges from -1 to 1), visualize with scatter plots, and test significance with hypothesis tests like t-test or p-value.

Calculate coefficient of correlation between the marks obtained by 10 students in Accountancy and statistics:

student: 1 2 3 4 5 6 7 8 9 10

Accountancy 45 70 65 30 90 40 50 75 85 60

statistics 35 90 70 40 95 40 60 80 80 50

a) the coefficient of correlation (Pearson's correlation coefficient) between the marks obtained in Accountancy and Statistics for 10 students

import numpy as np

# Marks data
accountancy_marks = np.array([45, 70, 65, 30, 90, 40, 50, 75, 85, 60])
statistics_marks = np.array([35, 90, 70, 40, 95, 40, 60, 80, 80, 50])

# Calculate Pearson correlation coefficient
correlation_coefficient = np.corrcoef(accountancy_marks, statistics_marks)[0, 1]

print(f"Pearson's correlation coefficient: {correlation_coefficient}")
q25. Discuss the 4 differences between correlation and regression.

a)Purpose: Correlation measures the strength and direction of the relationship between two variables. Regression predicts the value of one variable based on another.

Nature: Correlation is symmetrical; it measures the association between variables without implying causation. Regression is directional; it establishes a predictive model.

Variables: Correlation involves two variables treated equally. Regression distinguishes between independent (predictor) and dependent (outcome) variables.

Output: Correlation produces a correlation coefficient. Regression gives an equation to predict values.

Q26. Find the most likely price at Delhi corresponding to the price of Rs. 70 at Agra from the following data: Coefficient of correlation between the prices of the two places +0.8.

A)Given a correlation coefficient of +0.8 between Agra and Delhi prices, to find the price at Delhi corresponding to Rs. 70 at Agra, use regression or the correlation coefficient directly. If Rs. 70 at Agra corresponds to a high positive correlation, a likely price at Delhi could be higher than Rs. 70.

q27) In a partially destroyed laboratory record of an analysis of correlation data, the following results only are legible: Variance of x = 9, Regression equations are: (i) 8x-10y = —66; (ii) 40x -18y = 214. What are (a) the mean values of x and y, (b) the coefficient of correlation between x and y, (c) the c of y.

import numpy as np
from sympy import symbols, Eq, solve

# (a) Mean values of x and y

# Given regression equations
# 8x - 10y = -66
# 40x - 18y = 214

# Define symbols
x, y = symbols('x y')

# Define the equations
eq1 = Eq(8*x - 10*y, -66)
eq2 = Eq(40*x - 18*y, 214)

# Solve the equations simultaneously
solution = solve((eq1, eq2), (x, y))

mean_x = solution[x]
mean_y = solution[y]

print(f"Mean of x: {mean_x}")
print(f"Mean of y: {mean_y}")

# (b) Coefficient of correlation between x and y

# Given regression coefficients
b_yx = 8 / 10
b_xy = 18 / 40

# Correlation coefficient r
r = np.sqrt(b_yx * b_xy)

print(f"Correlation coefficient: {r}")

# (c) Constant of y

# Using mean values and regression coefficient
a = mean_y - b_yx * mean_x

print(f"Constant of y: {a}")
q28. What is Normal Distribution? What are the four Assumptions of Normal Distribution? Explain in detail.

a)Normal distribution is a bell-shaped curve that's symmetric around the mean. It's often called the Gaussian distribution. The mean, median, and mode are all equal and located at the center of the distribution.

Four Assumptions of Normal Distribution:

Symmetry: The distribution is symmetric around the mean.

Equal Mean, Median, and Mode: These measures of central tendency are all the same.

Asymptotic: The tails of the distribution approach the horizontal axis but never touch it.

Defined by Mean and Standard Deviation: The distribution's shape is determined by these two parameters.

Q29.Write all the characteristics or properties of the Normal Distribution Curve.

A)Characteristics of the Normal Distribution Curve

Symmetry: The curve is symmetric around the mean.

Mean, Median, and Mode: All are equal and located at the center.

Bell-shaped: The curve has a single peak at the mean.

Asymptotic: The tails approach the horizontal axis but never touch it.

Empirical Rule: About 68% of the data falls within one standard deviation of the mean, 95% within two, and 99.7% within three.

Q30)Which of the following options are correct about Normal Distribution Curve

(a) Within a range 0.6745 of o on both sides the middle 50% of the observations occur i,e. mean *0.67450 covers 50% area 25% on each side.

a): False. The correct range for covering 50% of the area is within ±0.6745σ, not μ×0.6745.

(b) Mean ±IS.D. (i,e.p ± 10) covers 68.268% area, 34.134 % area lies on either side of the mean.

b): True. μ±1σ covers approximately 68.268% of the area under the normal distribution curve.

(c) Mean ±2S.D. (i,e. ± 20) covers 95.45% area, 47.725% area lies on either side of the mean. (c): True.μ±2σ covers approximately 95.45% of the area under the normal distribution curve

(d) Mean S.D. (i,e. p ±30) covers 99.73% area, 49.856% area lies on the either side of the mean.

d) Mean S.D. (i,e. p ±30) covers 99.73% area, 49.856% area lies on the either side of the mean.

(e) Only 0.27% area is outside the range p *3.0

e): True. Only 0.27% of the area is outside the range μ±3σ.

Q31) The mean of a distribution is 60 with a standard deviation of 10. Assuming that the distribution is normal, what percentage of items be (i) between 60 and 72, (ii) between 50 and 60, (iii) beyond 72 and (iv) between 70 and 80? a)

Given: Mean = 60, Standard Deviation = 10.

(i) Between 60 and 72:
   - Use the Z-score formula: \( Z = \frac{X - \mu}{\sigma} \)
   - Calculate Z-scores: \( Z_{60} = \frac{60 - 60}{10} = 0 \),
     \( Z_{72} = \frac{72 - 60}{10} = 1.2 \).
   - Look up Z-table or use Python's scipy.stats.norm.cdf() function.
   - Approximate percentage: Around 21.22%.

(ii) Between 50 and 60:
   - Z-scores: \( Z_{50} = \frac{50 - 60}{10} = -1 \),
     \( Z_{60} = 0 \).
   - Approximate percentage: Around 34.13%.

(iii) Beyond 72 (greater than 72):
   - Z-score for 72: \( Z_{72} = 1.2 \).
   - Use complement rule: \( 1 - \text{cdf}(Z_{72}) \).
   - Approximate percentage: Around 11.35%.

(iv) Between 70 and 80:
   - Z-scores: \( Z_{70} = \frac{70 - 60}{10} = 1 \),
     \( Z_{80} = \frac{80 - 60}{10} = 2 \).
   - Approximate percentage: Around 31.73%.
.
q32. 15000 students sat for an examination. The mean marks was 49 and the distribution of marks had a standard deviation of 6. Assuming that the marks were normally distributed what proportion of students scored (a) more than 55 marks, (b) more than 70 marks

Given: Mean = 49, Standard Deviation = 6, Total students = 15000.

(a) Proportion of students scoring more than 55 marks:
   - Z-score for 55: \( Z_{55} = \frac{55 - 49}{6} = 1 \).
   - Use complement rule: \( 1 - \text{cdf}(Z_{55}) \).
   - Approximate percentage: Around 15.87%.

(b) Proportion of students scoring more than 70 marks:
   - Z-score for 70: \( Z_{70} = \frac{70 - 49}{6} = 3.5 \).
   - Use complement rule: \( 1 - \text{cdf}(Z_{70}) \).
   - Approximate percentage: Around 0.03%.
If the height of 500 students are normally distributed with mean 65 inch and standard deviation 5 inch. How many students have height : a) greater than 70 inch. b) between 60 and 70 inch.
Given: Mean = 65 inches, Standard Deviation = 5 inches, Total students = 500.

(a) Number of students with height greater than 70 inches:
   - Z-score for 70 inches: \( Z_{70} = \frac{70 - 65}{5} = 1 \).
   - Use the complement rule: \( 1 - \text{cdf}(Z_{70}) \).
   - Approximate percentage: Around 15.87%.
   - Number of students: \( \text{Total students} \times \text{Percentage} = 500 \times 0.1587 = 79.35 \).

   Since you can't have a fraction of a student, round to the nearest whole number:
   - Number of students greater than 70 inches: Approximately 79.

(b) Number of students with height between 60 and 70 inches:
   - Z-score for 60 inches: \( Z_{60} = \frac{60 - 65}{5} = -1 \).
   - Z-score for 70 inches: \( Z_{70} = \frac{70 - 65}{5} = 1 \).
   - Calculate the area between these two Z-scores using the difference of cdf values:
     \( \text{cdf}(Z_{70}) - \text{cdf}(Z_{60}) \).
   - Approximate percentage: Around 68.27%.
   - Number of students: \( 500 \times 0.6827 = 341.35 \).

   Round to the nearest whole number:
   - Number of students between 60 and 70 inches: Approximately 341.
35.A random sample of size 25 from a population gives the sample standard derivation to be 9.0. Test the hypothesis that the population standard derivation is 10.5. Hint(use chi- square distribution).

statistical hypothesis a)Statistical hypothesis is a statement o r assumption about the population parameters, tested using statistical methods to determine if there is enough evidence to reject or fail to reject the null hypothesis (H₀).

Errors in Hypothesis Testing: Type I Error: Occurs when we reject the null hypothesis (H₀) when it is actually true. It's a false positive.

Type II Error: Occurs when we fail to reject the null hypothesis (H₀) when it is actually false. It's a false negative.

Sample Explanation: Sample: A subset of individuals or objects selected from a larger population to represent it in a study or experiment.

Large Samples vs. Small Samples:

Large Samples: Typically have more than 30 observations. They tend to provide more reliable estimates of population parameters and are less affected by random fluctuations.

Small Samples: Usually have fewer than 30 observations. They can still provide insights but are more susceptible to random variability, making generalizations to the population more challenging.

Q37)100 students of a PW 101 obtained the following grades in Data Science paper : Grade : [A,B, C, D, E]

Total Frequency : [15,17, 30, 22, 16, 100]

Using the X(sigma)2 test , examine the hypothesis that the distribution of grades is uniform.

a)x`Given Data:

Grades: A, B, C, D, E

Frequencies: 15, 17, 30, 22, 16

Total students: 100

Calculate Expected Frequencies:

If the distribution were uniform, each grade would have an expected frequency of 100/5=20.

Set up Hypotheses:

Null Hypothesis (H₀): The distribution of grades is uniform.

Alternative Hypothesis (H₁): The distribution of grades is not uniform.

Compute Chi-square Statistic:

𝜒2=∑(𝑂𝑖−𝐸𝑖)2/Ei, where Oi is the observed frequency and Ei is the expected frequency for each grade.

Degrees of Freedom:

Degrees of freedom (df) = Number of categories - 1 = 5 - 1 = 4.

Compare with Critical Value: Use a Chi-square table or function (like scipy.stats.chi2) to find the critical value for χ2 with 4 degrees of freedom at a chosen significance level (e.g., 0.05).

Q36) Not Available in assignment PDF

Double-click (or enter) to edit

q38.Anova Test: TO study the performance Of three detergents and three different water temperatures the following whiteness readings were obtained with specially designed equipment.

Water temp | Detergents A | Detergents B | Detergents C

Cold Water | 57 | 55 | 67

Worm Water | 49 | 52 | 68

Hot Water | 54 | 46 | 58

Data:

Cold Water: [57, 55, 67]

Warm Water: [49, 52, 68]

Hot Water: [54, 46, 58]

Hypotheses:

H₀: No difference in mean whiteness among detergents and water temperatures. H₁: At least one mean whiteness is different

import pandas as pd
import scipy.stats as stats

# Data
data = {
    'Detergent A': [57, 49, 54],
    'Detergent B': [55, 52, 46],
    'Detergent C': [67, 68, 58]
}

df = pd.DataFrame(data, index=['Cold Water', 'Warm Water', 'Hot Water'])

# Reshape data for ANOVA
df_melt = pd.melt(df.reset_index(), id_vars=['index'], value_vars=['Detergent A', 'Detergent B', 'Detergent C'])
df_melt.columns = ['Water_Temperature', 'Detergent', 'Whiteness']

# ANOVA test
anova_result = stats.f_oneway(
    df_melt[df_melt['Detergent'] == 'Detergent A']['Whiteness'],
    df_melt[df_melt['Detergent'] == 'Detergent B']['Whiteness'],
    df_melt[df_melt['Detergent'] == 'Detergent C']['Whiteness']
)

anova_result
Q39.How would you create a basic Flask route that displays "Hello, World!" on the homepage?

# !pip install Flask
# Import Flask
from flask import Flask

# Create Flask app
app = Flask(__name__)

# Define route for homepage
@app.route('/')
def home():
    return "Hello, World!"

# Run the app
if __name__ == '__main__':
    app.run()
q40.Explain how to set up a Flask application to handle form submissions using POST requests.

from flask import Flask, request, render_template_string

app = Flask(__name__)

# Define the form template
form_template = '''
<!doctype html>
<html>
<body>
    <form method="POST" action="/">
        <input type="text" name="name">
        <input type="submit">
    </form>
</body>
</html>
'''

# Define the route to display the form
@app.route('/', methods=['GET', 'POST'])
def form():
    if request.method == 'POST':
        name = request.form['name']
        return f"Hello, {name}!"
    return render_template_string(form_template)

# Run the app
if __name__ == '__main__':
    app.run()
q41.Write a Flask route that accepts a parameter in the URL and displays it on the page.

from flask import Flask

app = Flask(__name__)

# Define the route with a parameter
@app.route('/hello/<name>')
def hello(name):
    return f"Hello, {name}!"

# Run the app
if __name__ == '__main__':
    app.run()
Q42.How can you implement user authentication in a Flask application?

!pip install Flask Flask-Login
from flask import Flask, render_template_string, redirect, url_for, request
from flask_login import LoginManager, UserMixin, login_user, login_required, logout_user, current_user

app = Flask(__name__)
app.secret_key = 'secretkey'
login_manager = LoginManager()
login_manager.init_app(app)

# User class
class User(UserMixin):
    def __init__(self, id):
        self.id = id

# User loader
@login_manager.user_loader
def load_user(user_id):
    return User(user_id)

# Login route
@app.route('/login', methods=['GET', 'POST'])
def login():
    if request.method == 'POST':
        user = User(request.form['username'])
        login_user(user)
        return redirect(url_for('protected'))
    return '''
    <form method="POST" action="/login">
        <input type="text" name="username">
        <input type="submit">
    </form>
    '''

# Protected route
@app.route('/protected')
@login_required
def protected():
    return f'Logged in as: {current_user.id}'

# Logout route
@app.route('/logout')
@login_required
def logout():
    logout_user()
    return 'Logged out!'

# Run the app
if __name__ == '__main__':
    app.run()
Q43.Describe the process of connecting a Flask app to a SQLite database using SQLAIchemy.

!pip install Flask-SQLAlchemy
from flask import Flask
from flask_sqlalchemy import SQLAlchemy

app = Flask(__name__)
app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///test.db'
db = SQLAlchemy(app)

# Define a model
class User(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    username = db.Column(db.String(80), unique=True, nullable=False)

# Create the database and tables
with app.app_context():
    db.create_all()

# Run the app
if __name__ == '__main__':
    app.run()
q44.How would you create a RESTful API endpoint in Flask that returns JSON data?

!pip install Flask
from flask import Flask, jsonify

app = Flask(__name__)

@app.route("/api/data", methods=['GET'])
def get_data():
    data = {'key': 'value', 'number': 42}
    return jsonify(data)

# Run the app
if __name__ == '__main__':
    app.run()
Q45.Explain how to use Flask—WTF to create and validate forms in a Flask application.

!pip install Flask-WTF
from flask import Flask, render_template_string, request
from flask_wtf import FlaskForm
from wtforms import StringField, SubmitField
from wtforms.validators import DataRequired

app = Flask(__name__)
app.secret_key = 'secretkey'

class MyForm(FlaskForm):
    name = StringField('Name', validators=[DataRequired()])
    submit = SubmitField('Submit')

@app.route('/', methods=['GET', 'POST'])
def form():
    form = MyForm()
    if form.validate_on_submit():
        return f"Hello, {form.name.data}!"
    return render_template_string('''
    <form method="POST">
        {{ form.hidden_tag() }}
        {{ form.name.label }} {{ form.name() }}
        {{ form.submit() }}
    </form>
    ''', form=form)

# Run the app
if __name__ == '__main__':
    app.run()
Q46.How can you implement file uploads in a Flask application?

!pip install Flask
from flask import Flask, request, render_template_string

app = Flask(__name__)
app.config['UPLOAD_FOLDER'] = '/path/to/upload'

@app.route('/', methods=['GET', 'POST'])
def upload_file():
    if request.method == 'POST':
        file = request.files['file']
        if file:
            file.save(os.path.join(app.config['UPLOAD_FOLDER'], file.filename))
            return 'File uploaded successfully'
    return '''
    <form method="POST" enctype="multipart/form-data">
        <input type="file" name="file">
        <input type="submit">
    </form>
    '''

# Run the app
if __name__ == '__main__':
    app.run()
Q47.Describe the Steps to create a Flask blueprint and why you might use one.

!pip install Flask
from flask import Flask, Blueprint

# Create a blueprint
my_blueprint = Blueprint('my_blueprint', __name__)

@my_blueprint.route('/hello')
def hello():
    return "Hello from blueprint!"

# Create Flask app
app = Flask(__name__)
app.register_blueprint(my_blueprint, url_prefix='/blueprint')

# Run the app
if __name__ == '__main__':
    app.run()
use a blueprint Organizes code into modular components.

Makes the app easier to manage and scale.

Q48.How would you deploy a Flask application to a production server using Gunicorn and Nginx?

# Install Gunicorn:
pip install gunicorn
# Run Flask app with Gunicorn:
gunicorn -w 4 myapp:app
# Nginx configuration:
# Edit /etc/nginx/sites-available/myapp:
server {
    listen 80;
    server_name your_domain;

    location / {
        proxy_pass http://127.0.0.1:8000;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }
}
# Enable Nginx site:
sudo ln -s /etc/nginx/sites-available/myapp /etc/nginx/sites-enabled
sudo systemctl restart nginx
Q49. Make a fully functional web application using flask, Mangodb. Signup,Signin page.And after successfully login Say hello Geeks message at webpage.

!pip install Flask Flask-PyMongo Flask-Bcrypt Flask-Login
# Flask app with MongoDB:
from flask import Flask, render_template_string, request, redirect, url_for
from flask_pymongo import PyMongo
from flask_bcrypt import Bcrypt
from flask_login import LoginManager, UserMixin, login_user, login_required, logout_user, current_user

app = Flask(__name__)
app.config['MONGO_URI'] = 'mongodb://localhost:27017/mydatabase'
app
50.Machine Learning:

• What is the difference between Series & Dataframes .

-*Series: A one-dimensional labeled array capable of holding any data type.

*DataFrame: A two-dimensional labeled data structure with columns of potentially different types.

• Create a database name Travel_planner in mysql ,and create a table name bookings in that which having attributes (user_id INT, flight_id INT, activity_id DATE) fill with some dummy value -Now you have to read the content of this table using pandas as dataframe.Show the output.

CREATE DATABASE Travel_planner;
USE Travel_planner;
CREATE TABLE bookings (
    user_id INT,
    flight_id INT,
    activity_date DATE
);
INSERT INTO bookings (user_id, flight_id, activity_date) VALUES 
(1, 101, '2023-07-01'),
(2, 102, '2023-07-02'),
(3, 103, '2023-07-03');
!pip install pymysql sqlalchemy pandas

import pandas as pd
from sqlalchemy import create_engine

# Create engine
engine = create_engine('mysql+pymysql://username:password@localhost/Travel_planner')

# Read table into DataFrame
df = pd.read_sql('SELECT * FROM bookings', engine)
print(df)
• Difference between loc and iloc.

- *loc: Access a group of rows and columns by labels or a boolean array.

*iloc: Access a group of rows and columns by integer positions (indices).

• What is the difference between supervised and unsupervised learning?

- *Supervised Learning: The model is trained on labeled data (input-output pairs).

*Unsupervised Learning: The model is trained on unlabeled data and finds hidden patterns or intrinsic structures.

• Explain the bias-variance tradeoff.

-*Bias: Error due to overly simplistic models, missing patterns.

*Variance: Error due to overly complex models, capturing noise.

*Tradeoff: Aim to find a balance; too much bias misses patterns, too much variance overfits.

• What are precision and recall? How are they different from accuracy?

- **Precision: True Positives/ True Positives+False Positives

**Recall: True Positives/True Positive+False Negatives

**Accuracy: True Positives+True Negatives/Total Samples

**Difference: Precision measures correctness of positive predictions; recall measures how well positives are identified.

• What is overfitting and how can it be prevented?

-**Overfitting: Model learns noise, not just patterns.

**Prevention: Use cross-validation, regularization, pruning, simpler models, more data.

• Explain the concept Of cross-validation.

-Concept: Split data into k-folds, train on k-1 folds, validate on remaining fold. Repeat k times, average results.

• What is the difference between a classification and a regression problem?

-*Classification: Predict categorical outcomes (e.g., spam/not spam).

*Regression: Predict continuous outcomes (e.g., house prices).

• Explain the concept Of ensemble learning.

=Concept: Combine multiple models to improve performance (e.g., bagging, boosting).

• What is gradient descent and how does it work?

= *Concept: Optimization algorithm to minimize loss function.

*How it Works: Update model parameters iteratively by moving in the direction of negative gradient.

• Describe the difference between batch gradient descent and stochastic gradient descent.

=*Batch: Uses all training data at once for updates.

*Stochastic: Uses one training sample per update, faster but noisier.

• What is the Curse Of dimensionality in machine learning?

=Concept: High-dimensional spaces make learning and generalizing difficult due to sparse data

• Explain the difference between Ll and L2 regularization.

-*L1 (Lasso): Adds absolute values of coefficients to loss function, can produce sparse models.

*L2 (Ridge): Adds squared values of coefficients to loss function, keeps all coefficients small.

• What is a confusion matrix and how is it used?

=Concept: Table to evaluate performance of classification models. Shows true vs predicted classes

• Define AUC-ROC curve.

=AUC: Area under the ROC curve, measures classifier performance.

ROC Curve: Plots true positive rate vs false positive rate across thresholds.

• Explain the k-nearest neighbors algorithm.

=Concept: Classify a data point based on the majority class of its k nearest neighbors.

How it Works: Calculate the distance between points, find the nearest k neighbors, and assign the majority label.

• Explain the basic concept of a Support Vector Machine (SVM).

*Concept: Find the optimal hyperplane that separates classes in a dataset.

*How it Works: Maximize the margin between the closest points (support vectors) of different classes

• How does the kernel trick work in SVM?

= Use kernel functions (e.g., linear, polynomial, RBF) to implicitly map input features

• What are the different types of kernels used in SVM and when would you use each? - *Linear: Use when data is linearly separable.

*Polynomial: Use when data has polynomial relationships.

*RBF (Gaussian): Use when data has complex boundaries.

• What is the hyperplane in SVM and how is it determined? =-Concept: The decision boundary that separates different classes.

-Determination: Found by maximizing the margin between the closest points of the classes.

• What are the pros and cons of using a Support Vector Machine (SVM)?

= -Pros: Effective in high-dimensional spaces, robust to overfitting with proper regularization.

-Cons: Computationally intensive, less effective on large datasets with noise

• Explain the difference between a hard margin and a soft margin SVM.

= *Hard Margin: No misclassifications allowed, only works with linearly separable data.

*Soft Margin: Allows some misclassifications, uses a regularization parameter to balance margin width and misclassification.

• Describe the process of constructing a decision tree.

=Process: Split data recursively based on feature values to create branches, stop when leaves are pure or other stopping criteria are met.

• Describe the working principle of a decision tree.

=Concept: Use a tree structure to make decisions based on feature values, starting from the root and moving to leaves.

• What is information gain and how is it used in decision trees?

=-Concept: Measure of how well a feature separates the classes.

-Usage: Select features with the highest information gain to split nodes.

• Explain Cini impurity and its role in decision trees.

*Concept: Measure of impurity or disorder in a dataset.

*Role: Used to select features by minimizing impurity in splits.

• What are the advantages and disadvantages of decision trees?

=*Advantages: Easy to understand, interpretable, handles both numerical and categorical data.

*Disadvantages: Prone to overfitting, sensitive to small data changes.

• How do random forests improve upon declsion trees?

= -Improvement: Combine multiple trees to reduce overfitting and improve generalization.

-How it Works: Create multiple trees using bootstrapped subsets of data and aggregate their predictions

• How does a random forest algorithm work? =1.Data Sampling: Random subsets of data created using bootstrapping.

2.Tree Construction: Multiple decision trees built with random feature subsets.

V3.oting: Trees vote on classification or average predictions for regression.

4.Final Prediction: Combines tree outputs for robust predictions.

• What is bootstrapping in the context of random forests?

=-Definition: Sampling technique with replacement to create multiple datasets.

-Purpose: Generates diverse subsets for training individual decision trees in Random Forests.

• Explain the concept of feature importance in random forests.

=Definition: Measures impact of each feature on model predictions.

Calculation: Analyzes how much each feature contributes to reducing prediction error across all trees.

• What are the key hyperparameters of a random forest and how do they affect the model?

=*Number of Trees: Increases model complexity and computational cost.

*Max Features: Controls the number of features considered for splitting.

*Tree Depth: Influences model complexity and overfitting

• Describe the logistic regression model and its assumptions.

=-Model: Linear regression for binary classification.

-Assumptions: Linear relationship between features and log-odds of the outcome.

• How does logistic regression handle binary classification problems?

=Output: Predicts probability of a binary outcome.

Decision: Classifies based on threshold (typically 0.5)

• What is the sigmoid function and how is it used in logistic regression?

=*Definition: S-shaped curve transforming input to a range between 0 and 1.

*Use: Converts logistic regression output into probabilities

• Explain the concept of the cost function in logistic regression.

=-Purpose: Measures model performance by penalizing incorrect predictions.

-Optimization: Minimizes cost using techniques like gradient descent

• How can logistic regression be extended to handle multiclass classification?

=One-vs-Rest: Trains multiple binary classifiers, one for each class.

Softmax Function: Outputs probabilities across multiple classes.

• What is the difference between Ll and L2 regularization in logistic regression?

=*L1 (Lasso): Penalizes absolute weights, promoting sparsity.

*L2 (Ridge): Penalizes squared weights, shrinking coefficients towards zero

• What is XGBoost and how does it differ from other boosting algorithms?

=*Definition: Gradient boosting library for optimized performance.

*Advantages: Handles large datasets, supports regularization, and manages missing values.

• Explain the concept of boosting in the context of ensemble learning.

=-Purpose: Combines weak learners sequentially to improve prediction accuracy.

-Process: Adjusts weights of misclassified instances to prioritize learning from errors.

• How does XGBoost handle missing values?

*Treatment: Automatically handles missing values during training.

*Process: Learns default directions for missing data, reducing prediction bias.

• What are the key hyperparameters in XGBoost and how do they affect model performance?

=1.Number of Trees: Controls the number of boosting rounds.

2.Learning Rate (eta): Scales the contribution of each tree.

3.Tree Depth (max_depth): Limits the depth of each tree.

4.Subsample: Fraction of training data used per tree.

5.Column Subsampling (colsample_bytree): Fraction of features used per tree.

• Describe the process of gradient boosting in XGBoost.

=Initialization: Starts with a simple model (usually a single leaf).

Iterative Improvement: Sequentially adds new models to correct errors made by existing models.

Gradient Descent: Optimizes a loss function by minimizing errors in predictions.

• What are the advantages and disadvantages of using XGBoost? = Advantage

*High Performance: Fast execution speed and scalability.

*Regularization: Reduces overfitting with regularization techniques.

Disadvantage *Complexity: Requires careful tuning of hyperparameters.

*Computationally Intensive: Can be resource-intensive, especially with large datasets

https://colab.research.google.com/drive/1hjgOanZBKDzd2bZ6wRMluW1u3AfxvCNn?usp=sharing
(if you get any problem with understanding it visit google colab using above link )    
